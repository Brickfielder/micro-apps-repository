<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Visuospatial Memory Trainer â€” Corsi Blocks</title>
<style>
    :root {
      --bg: #f7f8fb;
      --card: #ffffff;
      --text: #1f2937;
      --muted: #6b7280;
      --accent: #2563eb;
      --accent-2: #10b981;
      --warn: #ef4444;
      --shadow: 0 10px 30px rgba(0,0,0,0.08);
      --radius: 16px;
    }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; color: var(--text); background: var(--bg); }
    header { max-width: 1100px; margin: 24px auto 0; padding: 0 16px; }
    h1 { margin: 0 0 6px; font-weight: 800; letter-spacing: -0.02em; }
    p.lead { margin: 0; color: var(--muted); }

    .app { max-width: 1100px; margin: 16px auto 40px; padding: 16px; display: grid; grid-template-columns: 360px 1fr; gap: 16px; }
    @media (max-width: 900px) { .app { grid-template-columns: 1fr; } }

    .card { background: var(--card); border-radius: var(--radius); box-shadow: var(--shadow); padding: 16px; }
    .controls .row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 10px; }
    .controls label { font-size: 13px; color: var(--muted); display: block; margin-bottom: 4px; }
    .controls input[type="number"], .controls select { width: 100%; padding: 10px 12px; border: 1px solid #e5e7eb; border-radius: 10px; font-size: 14px; }

    .buttons { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 10px; }
    button { appearance: none; border: none; padding: 10px 14px; border-radius: 12px; background: var(--text); color: white; font-weight: 700; cursor: pointer; box-shadow: 0 6px 18px rgba(31,41,55,0.15); }
    button.secondary { background: #334155; }
    button.ghost { background: #eef2ff; color: #1e3a8a; }
    button.warn { background: var(--warn); }
    button:disabled { opacity: 0.5; cursor: not-allowed; }

    .grid-wrap { position: relative; display:flex; align-items:center; justify-content:center; height: 72vh; min-height: 430px; }
    .grid { width: min(78vmin, 700px); aspect-ratio: 1/1; margin: 0 auto; display: grid; gap: 14px; padding: 14px; background: #f3f4f6; border-radius: 20px; box-shadow: inset 0 0 0 2px #e5e7eb; }
    .grid.n3 { grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); }
    .grid.n4 { grid-template-columns: repeat(4, 1fr); grid-template-rows: repeat(4, 1fr); }

    .cell { position: relative; border-radius: 16px; background: #e5e7eb; box-shadow: inset 0 -6px 10px rgba(0,0,0,0.05); display:flex; align-items:center; justify-content:center; transition: transform 0.08s ease; user-select: none; }
    .cell:active { transform: scale(0.98); }
    .cell .dot { width: 22%; aspect-ratio: 1/1; border-radius: 50%; background: linear-gradient(180deg, #93c5fd, #2563eb); opacity: 0; transition: opacity 160ms ease; }
    .cell.show .dot { opacity: 1; }
    .cell.highlight { outline: 4px solid var(--accent); background: #dbeafe; }
    .cell.correct { outline: 4px solid var(--accent-2); background: #dcfce7; }
    .cell.wrong { outline: 4px solid var(--warn); background: #fee2e2; }

    .status { display:flex; gap: 8px; align-items:center; flex-wrap:wrap; margin-top: 8px; font-size: 14px; color: var(--muted); }
    .badge { display:inline-flex; align-items:center; gap: 6px; background:#eef2ff; color:#3730a3; padding:6px 10px; border-radius:999px; font-weight:700; }
    .badge.success { background:#ecfdf5; color:#065f46; }
    .badge.fail { background:#fef2f2; color:#991b1b; }

    .log { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; background:#0b1220; color:#d1e5ff; border-radius: 12px; padding:12px; max-height: 220px; overflow:auto; white-space: pre-wrap; }

    .footer-note { font-size: 12px; color: var(--muted); margin-top: 10px; }

    /* Countdown overlay */
    .countdown-overlay { position: absolute; inset: 0; display: none; align-items: center; justify-content: center; backdrop-filter: blur(2px); }
    .countdown-overlay.active { display: flex; }
    .countdown-bubble { background: rgba(17, 24, 39, 0.85); color: #fff; padding: 26px 34px; border-radius: 18px; box-shadow: var(--shadow); text-align: center; }
    .countdown-label { font-size: 14px; color: #d1d5db; margin-bottom: 6px; letter-spacing: 0.02em; }
    .countdown-number { font-size: clamp(38px, 6vmin, 72px); font-weight: 900; letter-spacing: 0.02em; }
    .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); white-space: nowrap; border: 0; }
  </style>
<meta content="Visuospatial_Blocks" name="app-slug"/><link href="/shared/theme.css" rel="stylesheet"/><script defer="" src="/shared/frame.js"></script><link href="../../../shared/theme.css" rel="stylesheet"/><script defer="" src="../../../shared/frame.js"></script><script defer="" src="../../../shared/clinician_feedback.js"></script>  <meta name="app-slug" content="visuospatial-blocks">
</head>
<body><main id="app-root">
<header>
<h1>Visuospatial Memory Trainer</h1>
<p class="lead">Corsi-style block sequences to train &amp; assess visuospatial span. Choose forward or backward recall, set sequence pacing, and download detailed logs.</p>
</header>
<main class="app">
<section class="card controls">
<h2 style="margin:0 0 12px">Settings</h2>
<div class="row">
<div>
<label>Mode</label>
<select id="mode">
<option value="forward">Forward (standard)</option>
<option value="backward">Backward (reverse order)</option>
</select>
</div>
<div>
<label>Grid size</label>
<select id="gridSize">
<option value="3">3 Ã— 3 (9 blocks)</option>
<option value="4">4 Ã— 4 (16 blocks)</option>
</select>
</div>
</div>
<div class="row">
<div>
<label>Start sequence length</label>
<input id="startLen" max="10" min="2" type="number" value="3"/>
</div>
<div>
<label>Max sequence length</label>
<input id="maxLen" max="20" min="3" type="number" value="9"/>
</div>
</div>
<div class="row">
<div>
<label>Stimulus ON (ms)</label>
<input id="onMs" max="2000" min="200" step="50" type="number" value="700"/>
</div>
<div>
<label>Inter-stimulus gap (ms)</label>
<input id="gapMs" max="1500" min="50" step="50" type="number" value="350"/>
</div>
</div>
<div class="row">
<div>
<label>Trials per length</label>
<input id="trialsPerLen" max="10" min="1" type="number" value="2"/>
</div>
<div>
<label>Fail rule</label>
<select id="failRule">
<option value="2">Stop after 2 fails at same length</option>
<option value="1">Stop after 1 fail at same length</option>
<option value="3">Stop after 3 fails at same length</option>
</select>
</div>
</div>
<div class="buttons">
<button id="startBtn">Start session</button>
<button class="secondary" disabled="" id="pauseBtn">Pause</button>
<button class="ghost" id="resetBtn">Reset</button>
<button class="secondary" disabled="" id="downloadBtn">Download CSV</button>
<button class="ghost" id="demoBtn">Quick demo</button>
</div>
<div class="status" id="status">
<span class="badge">Length: <strong id="lenBadge" style="margin-left:6px">â€”</strong></span>
<span class="badge" id="trialBadge">Trial: â€”</span>
<span class="badge success" id="bestSpan">Best span: â€”</span>
<span class="badge" id="modeBadge">Mode: forward</span>
</div>
<h3 style="margin:16px 0 8px">Session log</h3>
<div aria-live="polite" class="log" id="log"></div>
<p class="footer-note">Tip: For practice, run a short demo. For assessment, keep consistent timing and record the CSV.</p>
</section>
<section class="card">
<h2 style="margin:0 0 8px">Task area</h2>
<p id="instructions" style="margin-top:0;color:var(--muted)">
        Watch the blocks highlight in sequence. Then click the blocks to repeat the sequence <em>in the same order</em> (Forward) or <em>in reverse</em> (Backward). Try to go as long as you can. The sequence gets longer when you get it right.
      </p>
<div class="grid-wrap">
<div aria-label="Corsi grid" class="grid n3" id="grid" role="application"></div>
<!-- Countdown overlay -->
<div aria-atomic="true" aria-live="assertive" class="countdown-overlay" id="countdown">
<div class="countdown-bubble" role="status">
<div class="countdown-label">Get readyâ€¦</div>
<div class="countdown-number" id="countdownNum">2</div>
</div>
<span class="sr-only" id="countdownSr"></span>
</div>
</div>
</section>
</main>
<script>
    // Utility helpers
    const $ = sel => document.querySelector(sel);
    const $$ = sel => Array.from(document.querySelectorAll(sel));

    const gridEl = $('#grid');
    const logEl = $('#log');
    const countdownEl = $('#countdown');
    const countdownNumEl = $('#countdownNum');
    const countdownSr = $('#countdownSr');
    const status = {
      lenBadge: $('#lenBadge'),
      trialBadge: $('#trialBadge'),
      bestSpan: $('#bestSpan'),
      modeBadge: $('#modeBadge')
    };

    const controls = {
      mode: $('#mode'), gridSize: $('#gridSize'), startLen: $('#startLen'), maxLen: $('#maxLen'),
      onMs: $('#onMs'), gapMs: $('#gapMs'), trialsPerLen: $('#trialsPerLen'), failRule: $('#failRule'),
      startBtn: $('#startBtn'), pauseBtn: $('#pauseBtn'), resetBtn: $('#resetBtn'), downloadBtn: $('#downloadBtn'), demoBtn: $('#demoBtn')
    };

    let state = {
      running: false,
      paused: false,
      awaitingInput: false,
      sequence: [],
      inputSeq: [],
      seqLen: 3,
      trialAtLen: 0,
      failsAtLen: 0,
      bestSpan: 0,
      gridN: 3,
      mode: 'forward',
      blockCount: 9,
      playTimer: null,
      timestamps: [], // presentation timestamps per item
      responseTimes: [], // per click
      sessionRows: [], // for CSV
      sessionId: 'S' + Math.random().toString(36).slice(2,8),
    };

    function initGrid(n) {
      gridEl.classList.toggle('n3', n === 3);
      gridEl.classList.toggle('n4', n === 4);
      gridEl.innerHTML = '';
      const cells = n*n;
      for (let i=0;i<cells;i++) {
        const cell = document.createElement('button');
        cell.className = 'cell';
        cell.setAttribute('data-idx', i);
        cell.setAttribute('aria-label', 'Block ' + (i+1));
        cell.innerHTML = '<div class="dot"></div>';
        cell.addEventListener('click', onCellClick);
        gridEl.appendChild(cell);
      }
    }

    function sampleSequence(len, max) {
      const arr = [...Array(max).keys()];
      // Shuffle and take first len (no repeats)
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr.slice(0, len);
    }

    async function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

    function log(line){
      const ts = new Date().toLocaleTimeString();
      logEl.textContent += `[${ts}] ${line}\n`;
      logEl.scrollTop = logEl.scrollHeight;
    }

    function updateBadges(){
      status.lenBadge.textContent = state.seqLen;
      status.trialBadge.textContent = `Trial: ${state.trialAtLen+1}`;
      status.bestSpan.textContent = `Best span: ${state.bestSpan}`;
      status.modeBadge.textContent = `Mode: ${state.mode}`;
    }

    // NEW: simple visual + screen-reader countdown before each sequence
    async function showCountdown(seconds = 2){
      // If paused, wait until resumed before showing
      while (state.paused) { await sleep(100); }

      countdownEl.classList.add('active');
      for (let s = seconds; s >= 1; s--) {
        countdownNumEl.textContent = s;
        countdownSr.textContent = `Starting in ${s} second${s===1?'':'s'}`;
        log(`Starting in ${s}â€¦`);
        await sleep(1000);
        if (!state.running) break; // if session ended
        while (state.paused) { await sleep(100); }
      }
      countdownEl.classList.remove('active');
    }

    async function playSequence() {
      state.awaitingInput = false;
      state.inputSeq = [];
      state.responseTimes = [];
      state.timestamps = [];
      const onMs = parseInt(controls.onMs.value,10);
      const gapMs = parseInt(controls.gapMs.value,10);
      const cells = $$('.cell');

      for (let i=0;i<state.sequence.length;i++) {
        while (state.paused) { await sleep(100); }
        const idx = state.sequence[i];
        const cell = cells[idx];
        cell.classList.add('show');
        state.timestamps.push(performance.now());
        await sleep(onMs);
        cell.classList.remove('show');
        await sleep(gapMs);
      }
      state.awaitingInput = true;
      state.inputStart = performance.now();
      log('Your turnâ€¦');
    }

    async function runTrial() {
      // Prepare sequence length and counters
      updateBadges();
      const cells = $$('.cell');
      cells.forEach(c=>{ c.classList.remove('correct','wrong','highlight'); });

      // Create new sequence of current length
      state.sequence = sampleSequence(state.seqLen, state.blockCount);
      log(`Presenting length ${state.seqLen} (trial ${state.trialAtLen+1})`);

      // NEW: countdown before the sequence is played
      await showCountdown(2); // 2 â†’ 1

      await playSequence();
    }

    function evaluateResponse() {
      const presented = [...state.sequence];
      const expected = (state.mode === 'forward') ? presented : [...presented].reverse();
      const isCorrect = expected.length === state.inputSeq.length && expected.every((v,i)=>v===state.inputSeq[i]);

      const row = {
        sessionId: state.sessionId,
        timestamp: new Date().toISOString(),
        mode: state.mode,
        gridN: state.gridN,
        blockCount: state.blockCount,
        seqLen: state.seqLen,
        trial: state.trialAtLen+1,
        presented: presented.join('-'),
        expected: expected.join('-'),
        response: state.inputSeq.join('-'),
        correct: isCorrect ? 1 : 0,
        rt_first_ms: state.responseTimes[0] ?? '',
        rt_mean_ms: state.responseTimes.length ? Math.round(state.responseTimes.reduce((a,b)=>a+b,0)/state.responseTimes.length) : '',
        rt_total_ms: state.inputSeq.length ? Math.round(state.responseTimes.reduce((a,b)=>a+b,0)) : '',
      };
      state.sessionRows.push(row);

      // Visual feedback
      const cells = $$('.cell');
      if (isCorrect) {
        state.bestSpan = Math.max(state.bestSpan, state.seqLen);
        expected.forEach(i => cells[i].classList.add('correct'));
        log(`âœ… Correct at length ${state.seqLen}`);
      } else {
        // highlight expected vs wrong clicks
        expected.forEach(i => cells[i].classList.add('highlight'));
        state.inputSeq.forEach((i, idx) => {
          const c = cells[i];
          if (expected[idx] !== i) c.classList.add('wrong');
        });
        log(`âŒ Wrong at length ${state.seqLen}`);
      }
      updateBadges();

      // Progress rules
      const failCap = parseInt(controls.failRule.value,10);
      if (isCorrect) {
        state.trialAtLen += 1;
        state.failsAtLen = 0;
        const tPerLen = parseInt(controls.trialsPerLen.value,10);
        if (state.trialAtLen >= tPerLen) {
          state.seqLen += 1;
          state.trialAtLen = 0;
        }
      } else {
        state.failsAtLen += 1;
        state.trialAtLen += 1; // counts as a trial at this length
        if (state.failsAtLen >= failCap) {
          endSession(`Stopped after ${failCap} fail(s) at length ${state.seqLen}.`);
          return;
        }
      }

      // Stop if reached max length
      const maxLen = parseInt(controls.maxLen.value,10);
      if (state.seqLen > maxLen) {
        endSession(`Reached max length ${maxLen}.`);
        return;
      }

      // Queue next trial
      setTimeout(()=>{
        if (state.running) runTrial();
      }, 700);
    }

    function onCellClick(e){
      if (!state.running || !state.awaitingInput) return;
      const idx = parseInt(e.currentTarget.getAttribute('data-idx'),10);
      // record response time relative to previous click (or to input start)
      const now = performance.now();
      const prev = state.inputSeq.length ? state.lastClickTs : state.inputStart;
      state.responseTimes.push(now - prev);
      state.lastClickTs = now;

      state.inputSeq.push(idx);
      e.currentTarget.classList.add('highlight');

      // If reached needed length, evaluate
      const targetLen = state.sequence.length;
      const needed = (state.mode === 'forward') ? targetLen : targetLen; // same length of clicks
      if (state.inputSeq.length >= needed) {
        state.awaitingInput = false;
        evaluateResponse();
      }
    }

    function startSession(demo=false){
      // Read controls
      state.mode = controls.mode.value;
      state.gridN = parseInt(controls.gridSize.value,10);
      state.blockCount = state.gridN * state.gridN;
      initGrid(state.gridN);
      state.seqLen = parseInt(controls.startLen.value,10);
      state.trialAtLen = 0; state.failsAtLen = 0; state.bestSpan = 0; state.sessionRows = [];
      updateBadges();

      state.running = true; state.paused = false; controls.pauseBtn.disabled = false; controls.downloadBtn.disabled = true;
      controls.startBtn.disabled = true; logEl.textContent = '';
      log(`Session ${state.sessionId} started (${state.mode}, ${state.gridN}Ã—${state.gridN}).`);

      if (demo) { // quick 2 trials demo
        controls.startLen.value = 3; controls.maxLen.value = 4; controls.trialsPerLen.value = 1; controls.onMs.value = 600; controls.gapMs.value = 250;
        state.seqLen = 3;
      }
      runTrial();
    }

    function endSession(reason='Session ended.'){
      state.running = false; state.awaitingInput = false; controls.pauseBtn.disabled = true; controls.downloadBtn.disabled = false; controls.startBtn.disabled = false;
      log(`â€” ${reason} Best span: ${state.bestSpan}.`);
    }

    function resetAll(){
      state.running = false; state.awaitingInput = false; state.sessionRows = []; logEl.textContent = '';
      controls.pauseBtn.disabled = true; controls.downloadBtn.disabled = true; controls.startBtn.disabled = false;
      state.bestSpan = 0; state.seqLen = parseInt(controls.startLen.value,10); state.trialAtLen = 0; state.failsAtLen = 0;
      initGrid(parseInt(controls.gridSize.value,10));
      updateBadges();
      log('Reset. Configure settings and press Start.');
    }

    function togglePause(){
      if (!state.running) return;
      state.paused = !state.paused;
      controls.pauseBtn.textContent = state.paused ? 'Resume' : 'Pause';
      log(state.paused ? 'Paused.' : 'Resumed.');
    }

    function toCSV(rows){
      const headers = ['sessionId','timestamp','mode','gridN','blockCount','seqLen','trial','presented','expected','response','correct','rt_first_ms','rt_mean_ms','rt_total_ms'];
      const lines = [headers.join(',')];
      for (const r of rows){
        const vals = headers.map(h=>String(r[h] ?? '').replace(/,/g,';'));
        lines.push(vals.join(','));
      }
      return lines.join('\n');
    }

    function downloadCSV(){
      if (!state.sessionRows.length){ alert('No data to download yet.'); return; }
      const csv = toCSV(state.sessionRows);
      const blob = new Blob([csv], {type:'text/csv'});
      const a = document.createElement('a');
      const filename = `visuospatial_memory_${state.sessionId}.csv`;
      a.href = URL.createObjectURL(blob);
      a.download = filename; a.click();
      URL.revokeObjectURL(a.href);
    }

    // Wire up controls
    controls.startBtn.addEventListener('click', () => startSession(false));
    controls.demoBtn.addEventListener('click', () => startSession(true));
    controls.resetBtn.addEventListener('click', resetAll);
    controls.pauseBtn.addEventListener('click', togglePause);
    controls.downloadBtn.addEventListener('click', downloadCSV);

    // Initialize
    initGrid(3);
    updateBadges();
    log('Ready. Choose settings and press Start session.');
  </script>
<section id="clinician-notes">
<div style="background: var(--surface); border: 1px solid var(--line); border-radius: 12px; box-shadow: var(--shadow); padding: 16px; margin-top: 24px;">
<label for="clinician-comment" style="display:block;font-weight:600;margin-bottom:8px;">
      Clinician comments (optional)
    </label>
<textarea id="clinician-comment" placeholder="Enter any notes relevant to this session..." rows="4" style="width:100%; padding:10px; border-radius:8px; border:1px solid var(--line); font: inherit; resize: vertical;"></textarea>
<p style="margin:8px 0 0; color: var(--muted); font-size: 0.9rem;">
      This note will be added as <code>clinician_comment</code> in the exported CSV.
    </p>
</div>
</section></main></body>
</html>

