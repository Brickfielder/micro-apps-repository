<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>Neglect Overlay ‚Äî Animal Targets (High Contrast)</title>
<style>
  html, body { height:100%; margin:0; background:#000; overflow:hidden; }
  #wrap { position: fixed; inset: 0; }
  #cam {
    position:absolute; inset:0;
    width:100vw; height:100vh; object-fit: cover;
    transform: translateZ(0);
    background:#000; /* visible fallback */
  }
  #overlay { position:absolute; inset:0; touch-action:none; z-index:10; }
  .midline { position:absolute; top:0; bottom:0; left:50%; width:0; border-left:1px dashed rgba(255,255,255,.25); pointer-events:none; z-index:9; }

  /* HUD bottom-left */
  .hud {
    position: fixed; left: 12px; bottom: 12px; z-index: 20;
    background: rgba(0,0,0,.55); color:#fff; padding: 10px 12px; border-radius: 14px;
    font: 600 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji";
    backdrop-filter: blur(6px);
  }
  .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  .stat { padding:4px 8px; border:1px solid rgba(255,255,255,.2); border-radius:10px; font-weight:700; }
  .stat small { font-weight:600; opacity:.7; margin-left:6px; }

  /* Controls: vertical stack on right edge */
  .controls {
    position: fixed; right: 12px; top: 12px; z-index: 21;
    display:flex; flex-direction:column; gap:8px; align-items:flex-end;
  }
  .panel {
    background: rgba(0,0,0,.55); color:#fff; padding: 10px 12px; border-radius: 14px;
    font: 600 13px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji";
    backdrop-filter: blur(6px);
  }
  label { display:flex; align-items:center; gap:6px; font-weight:600; }
  select, input[type=number] {
    appearance:none; background: rgba(255,255,255,.1); color:#fff; border:1px solid rgba(255,255,255,.25);
    border-radius:10px; padding:6px 8px; font: 600 13px/1 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial;
    width: fit-content;
  }
  .btn {
    appearance:none; border:1px solid rgba(255,255,255,.3); background: rgba(255,255,255,.08); color:#fff;
    padding: 8px 12px; border-radius: 12px; font: 700 13px/1 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial;
    cursor:pointer;
  }
  .btn:disabled { opacity: .5; cursor: default; }

  /* Results dialog */
  #results {
    position: fixed; inset: 0; display:none; align-items:center; justify-content:center; z-index: 30;
    background: rgba(0,0,0,.5); backdrop-filter: blur(4px);
  }
  #results .card {
    width:min(92vw, 540px);
    background: rgba(15,15,20,.95); color:#fff; border:1px solid rgba(255,255,255,.1);
    border-radius: 16px; padding: 16px; box-shadow: 0 20px 60px rgba(0,0,0,.5);
    font: 600 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial;
  }
  #results h2 { margin: 0 0 10px; font-size: 18px; }
  #results table { width:100%; border-collapse: collapse; margin: 8px 0 12px; }
  #results td { padding:6px 4px; border-bottom:1px solid rgba(255,255,255,.06); }
  #results .card .actions { display:flex; gap:8px; justify-content:flex-end; margin-top:8px; }

  /* Orientation gate overlay */
  #orientGate {
    position: fixed; inset:0; z-index: 40; display:none;
    align-items:center; justify-content:center; text-align:center;
    background: rgba(0,0,0,0.8); color:#fff;
    font: 700 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial;
    padding: 24px;
  }
  #orientGate .box {
    max-width: 520px; padding: 20px; border:1px solid rgba(255,255,255,.2); border-radius:16px;
    background: rgba(15,15,20,.9);
  }
  #orientGate h3 { margin:0 0 10px; font-size:18px; }
  #orientGate p { margin: 8px 0 0; opacity:.9; }

  /* Camera error overlay */
  #camError {
    position: fixed; left: 12px; top: 50%; transform: translateY(-50%);
    z-index: 50; max-width: 520px;
    background: rgba(160,20,20,0.88); color:#fff; border:1px solid rgba(255,255,255,.25);
    border-radius: 14px; padding: 12px;
    font: 700 13px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial;
    display:none;
  }
  #camError code { font-weight: 700; background: rgba(255,255,255,.15); padding: 2px 6px; border-radius: 6px; }
</style>
</head>
<body>
  <div id="wrap">
    <video id="cam" autoplay playsinline muted></video>
    <div class="midline" aria-hidden="true"></div>
    <canvas id="overlay" aria-label="Interaction canvas"></canvas>
  </div>

  <!-- Live HUD (bottom-left) -->
  <div class="hud" id="hud">
    <div class="row">
      <div class="stat" id="time">‚è± 01:00</div>
      <div class="stat" id="leftStat">‚¨ÖÔ∏è L: 0</div>
      <div class="stat" id="rightStat">‚û°Ô∏è R: 0</div>
      <div class="stat" id="diffStat">Œî R‚àíL: 0</div>
      <div class="stat" id="liStat">LI: 0.00 <small>( (R‚àíL)/(R+L) )</small></div>
    </div>
  </div>

  <!-- Controls (right edge, vertical) -->
  <div class="controls">
    <div class="panel" id="ctlPanel">
      <label>Difficulty
        <select id="difficulty">
          <option value="easy">Easy</option>
          <option value="normal" selected>Normal</option>
          <option value="hard">Difficult</option>
        </select>
      </label>
      <label>Items
        <input id="concurrency" type="number" min="1" max="12" step="1" value="6" />
      </label>
      <div style="display:flex; gap:8px; margin-top:8px; flex-wrap:wrap;">
        <button class="btn" id="fsBtn" type="button">Fullscreen & lock</button>
        <button class="btn" id="startBtn">Start 1-min</button>
        <button class="btn" id="stopBtn" disabled>Stop</button>
      </div>
    </div>
  </div>

  <!-- Results -->
  <div id="results" role="dialog" aria-modal="true">
    <div class="card">
      <h2>Session results</h2>
      <table><tbody id="resultsBody"></tbody></table>
      <div class="actions">
        <button class="btn" id="csvBtn">Download CSV</button>
        <button class="btn" id="dismissBtn">Close</button>
      </div>
    </div>
  </div>

  <!-- Orientation gate -->
  <div id="orientGate" aria-live="polite">
    <div class="box">
      <h3>Please rotate your device</h3>
      <p>This task must run in <b>landscape</b> for consistent measurement. Rotate the phone to continue.</p>
      <p style="margin-top:12px; opacity:.85;">Tip: tap <b>Fullscreen & lock</b> to try locking landscape on supported devices.</p>
    </div>
  </div>

  <!-- Camera error -->
  <div id="camError"></div>

<script>
(async function(){
  // --- Camera ---
  const cam = document.getElementById('cam');
  cam.setAttribute('playsinline','');
  cam.setAttribute('muted','');
  cam.playsInline = true;
  cam.muted = true;

  const camError = document.getElementById('camError');

  let camReady = false;
  async function ensureCamera() {
    if (camReady && cam.srcObject) {
      try { await cam.play(); } catch(_) {}
      return true;
    }
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      showError("This browser doesn‚Äôt support <code>getUserMedia</code>. Try Chrome on Android or Safari on iOS.");
      return false;
    }
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: { ideal: "environment" },
          width: { ideal: 1280 }, height: { ideal: 720 }, aspectRatio: { ideal: 16/9 }
        },
        audio: false
      });
      cam.srcObject = stream;
      // Some mobiles require an explicit play() after attaching the stream:
      await cam.play();
      camReady = true;
      hideError();
      return true;
    } catch (e) {
      const onGithubBlob = /github\.com/.test(location.hostname) && /\/blob\//.test(location.pathname);
      const insecure = location.protocol !== 'https:' && location.hostname !== 'localhost';
      let hint = '';
      if (onGithubBlob) hint = "Open the <b>GitHub Pages</b> URL instead:<br><code>https://brickfielder.github.io/micro-apps-repository/docs/apps/ar-neglect-proto/index.html</code>";
      else if (insecure) hint = "Camera requires a <b>secure context</b> (HTTPS) or <b>localhost</b>.";
      showError(`Camera access failed: <code>${e.name}</code> ‚Äî ${e.message}${hint ? "<br><br>"+hint : ""}`);
      return false;
    }
  }

  function showError(html){
    camError.innerHTML = html;
    camError.style.display = 'block';
  }
  function hideError(){
    camError.style.display = 'none';
    camError.textContent = '';
  }

  // Try to pre-warm camera on load (best effort)
  ensureCamera();

  // --- Canvas setup ---
  const cvs = document.getElementById('overlay');
  const ctx = cvs.getContext('2d', { alpha: true, desynchronized: true });
  let dpr = Math.max(1, window.devicePixelRatio || 1);

  function layout(){
    cvs.style.width = '100vw'; cvs.style.height = '100vh';
    const r = cvs.getBoundingClientRect();
    cvs.width = Math.round(r.width * dpr);
    cvs.height = Math.round(r.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  layout();

  addEventListener('resize', ()=> { setTimeout(layout, 80); checkOrientationGate(); });
  addEventListener('orientationchange', ()=> { setTimeout(layout, 300); checkOrientationGate(); });

  // --- UI rect helpers (to avoid spawning/overlap) ---
  function rectFrom(el){
    if (!el) return null;
    const cr = cvs.getBoundingClientRect();
    const r = el.getBoundingClientRect();
    return { x1: r.left - cr.left, y1: r.top - cr.top, x2: r.right - cr.left, y2: r.bottom - cr.top };
  }
  function inflate(rect, pad){ return { x1: rect.x1 - pad, y1: rect.y1 - pad, x2: rect.x2 + pad, y2: rect.y2 + pad }; }
  function intersects(a,b){ return !(a.x2 < b.x1 || a.x1 > b.x2 || a.y2 < b.y1 || a.y1 > b.y2); }
  function tokenRectAt(x, y, w, h){ return { x1: x - w/2, y1: y - h/2, x2: x + w/2, y2: y + h/2 }; }
  function getUIRects(pad=12){
    const hud = rectFrom(document.getElementById('hud'));
    const ctl = rectFrom(document.getElementById('ctlPanel'));
    const arr = [];
    if (hud) arr.push(inflate(hud, pad));
    if (ctl) arr.push(inflate(ctl, pad));
    return arr;
  }

  // --- Parameters & state ---
  const ANIMALS = ['üê∂','üê±','üê≠','üêπ','üê∞','ü¶ä','üêª','üêº','üê®','üêØ','ü¶Å','üêÆ','üê∑','üê∏','üêµ','üêî','üêß','üê¶','üê§','üê∫','ü¶Ñ','üêô','üê¨','üê†','üê≥'];
  const ui = {
    diff: document.getElementById('difficulty'),
    conc: document.getElementById('concurrency'),
    start: document.getElementById('startBtn'),
    stop: document.getElementById('stopBtn'),
    fsBtn: document.getElementById('fsBtn'),
    time: document.getElementById('time'),
    left: document.getElementById('leftStat'),
    right: document.getElementById('rightStat'),
    diffStat: document.getElementById('diffStat'),
    li: document.getElementById('liStat'),
    results: document.getElementById('results'),
    resultsBody: document.getElementById('resultsBody'),
    csvBtn: document.getElementById('csvBtn'),
    dismissBtn: document.getElementById('dismissBtn'),
    orientGate: document.getElementById('orientGate'),
  };

  let tokens = [];
  let sessionActive = false;
  let timerId = null;
  let animId = null;
  let t0 = 0;
  const DURATION_MS = 60_000; // 1 minute fixed

  const stats = {
    left: 0, right: 0, taps: 0,
    spawnedLeft: 0, spawnedRight: 0,
    events: [], // {t,x,y,side,difficulty,animal}
  };

  function resetStats(){
    stats.left = stats.right = stats.taps = 0;
    stats.spawnedLeft = stats.spawnedRight = 0;
    stats.events.length = 0;
    updateHUD();
  }

  function difficultySpec(){
    switch (ui.diff.value) {
      case 'easy':   return { w: 170, h: 170, drift: 0.0,  rot: 0.0  };
      case 'normal': return { w: 140, h: 140, drift: 0.12, rot: 0.0015 };
      case 'hard':   return { w: 110, h: 110, drift: 0.25, rot: 0.003  };
    }
  }

  // Random spawn that avoids UI rects (increments L/R only on success)
  function spawnToken(sideHint = null){
    const r = cvs.getBoundingClientRect();
    const W = r.width, H = r.height;
    const spec = difficultySpec();
    const margin = 24;
    const uiRects = getUIRects(12);

    let tries = 80;
    let x, y, sideAtSpawn = null;
    while (tries-- > 0){
      if (sideHint === 'L') {
        x = margin + spec.w/2 + Math.random() * Math.max(10, (W/2 - margin - spec.w));
        sideAtSpawn = 'L';
      } else if (sideHint === 'R') {
        x = (W/2 + margin + spec.w/2) + Math.random() * Math.max(10, (W/2 - margin - spec.w));
        sideAtSpawn = 'R';
      } else {
        x = margin + spec.w/2 + Math.random() * Math.max(10, (W - (margin + spec.w)));
        sideAtSpawn = (x < W/2) ? 'L' : 'R';
      }
      y = margin + spec.h/2 + Math.random() * Math.max(10, (H - (margin + spec.h)));

      const tRect = tokenRectAt(x, y, spec.w, spec.h);
      if (!uiRects.some(u => intersects(tRect, u))) break;
    }

    if (sideAtSpawn === 'L') stats.spawnedLeft++;
    else if (sideAtSpawn === 'R') stats.spawnedRight++;

    const hue = Math.floor(Math.random()*360); // rim tint
    const animal = ANIMALS[Math.floor(Math.random()*ANIMALS.length)];
    tokens.push({
      x, y, w: spec.w, h: spec.h, r: 0,
      hue, animal,
      vx: (Math.random()*2-1) * spec.drift,
      vy: (Math.random()*2-1) * spec.drift,
      vr: (Math.random()*2-1) * spec.rot,
      id: Math.random().toString(36).slice(2),
    });
  }

  function maintain(){
    const target = clamp(parseInt(ui.conc.value||6,10), 1, 12);
    while (tokens.length < target) {
      const side = (stats.spawnedLeft <= stats.spawnedRight) ? 'L' : 'R';
      spawnToken(side);
    }
  }

  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

  // --- Drawing: ANIMAL tokens (HIGH CONTRAST "sticker") ---
  function drawToken(t){
    const radius = Math.min(t.w, t.h) * 0.58;
    ctx.save();
    ctx.translate(t.x, t.y);
    ctx.rotate(t.r);

    // Outer soft shadow (makes whole sticker pop)
    ctx.shadowColor = "rgba(0,0,0,0.55)";
    ctx.shadowBlur = 28; ctx.shadowOffsetY = 12;

    // Base disc gradient
    const rg = ctx.createRadialGradient(0, 0, radius*0.15, 0, 0, radius);
    rg.addColorStop(0, "rgba(255,255,255,0.98)");
    rg.addColorStop(1, "rgba(245,245,245,0.98)");
    ctx.beginPath(); ctx.arc(0,0, radius, 0, Math.PI*2); ctx.fillStyle = rg; ctx.fill();

    // Colored rim + dark outer stroke
    ctx.lineWidth = Math.max(2, radius*0.10);
    ctx.strokeStyle = `hsl(${t.hue} 80% 45%)`; ctx.stroke();
    ctx.lineWidth = Math.max(1.5, radius*0.05);
    ctx.strokeStyle = "rgba(0,0,0,0.7)"; ctx.stroke();

    // Emoji with subtle inner glow
    const fontPx = Math.round(radius * 1.6);
    ctx.shadowColor = "rgba(0,0,0,0.35)";
    ctx.shadowBlur = 10; ctx.shadowOffsetY = 4;
    ctx.font = `900 ${fontPx}px "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji", system-ui, sans-serif`;
    ctx.textAlign = "center"; ctx.textBaseline = "middle";
    ctx.fillText(t.animal, 0, -fontPx*0.03);
    ctx.shadowBlur = 0; ctx.shadowOffsetY = 0;

    ctx.restore();
  }

  function draw(){
    ctx.clearRect(0,0,cvs.width/dpr,cvs.height/dpr);
    for (const t of tokens) drawToken(t);
  }

  // --- Animation (drift + keep off UI + edges) ---
  function tick(){
    const r = cvs.getBoundingClientRect();
    const W = r.width, H = r.height;
    const uiRects = getUIRects(12);

    for (const t of tokens){
      t.x += t.vx; t.y += t.vy; t.r += t.vr;

      // Edge bounce
      const m = 20;
      if (t.x - t.w/2 < m) { t.x = m + t.w/2; t.vx *= -0.9; }
      if (t.x + t.w/2 > W - m) { t.x = W - m - t.w/2; t.vx *= -0.9; }
      if (t.y - t.h/2 < m) { t.y = m + t.h/2; t.vy *= -0.9; }
      if (t.y + t.h/2 > H - m) { t.y = H - m - t.h/2; t.vy *= -0.9; }

      // Avoid UI panels (AABB approx)
      const tr = tokenRectAt(t.x, t.y, t.w, t.h);
      for (const u of uiRects){
        if (intersects(tr, u)){
          const dxLeft = Math.abs(tr.x2 - u.x1);
          const dxRight = Math.abs(u.x2 - tr.x1);
          const dyTop = Math.abs(tr.y2 - u.y1);
          const dyBottom = Math.abs(u.y2 - tr.y1);
          const minDelta = Math.min(dxLeft, dxRight, dyTop, dyBottom);
          if (minDelta === dxLeft) { t.x = u.x1 - t.w/2 - 1; t.vx = -Math.abs(t.vx); }
          else if (minDelta === dxRight) { t.x = u.x2 + t.w/2 + 1; t.vx = Math.abs(t.vx); }
          else if (minDelta === dyTop) { t.y = u.y1 - t.h/2 - 1; t.vy = -Math.abs(t.vy); }
          else { t.y = u.y2 + t.h/2 + 1; t.vy = Math.abs(t.vy); }
        }
      }
    }

    maintain();
    draw();
    animId = requestAnimationFrame(tick);
  }

  // --- Interaction (circular hit test) ---
  function pickToken(x, y){
    for (let i = tokens.length-1; i >= 0; i--){
      const t = tokens[i];
      const dx = x - t.x, dy = y - t.y;
      const r = Math.min(t.w, t.h) * 0.58;
      if (dx*dx + dy*dy <= r*r) return i;
    }
    return -1;
  }

  cvs.addEventListener('pointerdown', e=>{
    if (!sessionActive) return;
    const rect = cvs.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const i = pickToken(x, y);
    if (i !== -1){
      const side = (x < rect.width/2) ? 'L' : 'R';
      if (side === 'L') stats.left++; else stats.right++;
      stats.taps++;
      stats.events.push({
        t: Date.now() - t0, x: Math.round(x), y: Math.round(y),
        side, difficulty: ui.diff.value, animal: tokens[i].animal
      });
      tokens.splice(i,1);
      updateHUD();
      draw();
    }
  });

  // --- Session control ---
  const startBtn = document.getElementById('startBtn');
  startBtn.onclick = async ()=>{
    if (!isLandscape()){ checkOrientationGate(); return; }
    // Ensure camera on user gesture ‚Äî improves reliability on Android
    const ok = await ensureCamera();
    if (!ok) return;
    try { await tryFullscreenAndLock(); } catch(_) {}

    if (sessionActive) return;
    sessionActive = true;
    startBtn.disabled = true;
    ui.stop.disabled = false;
    ui.diff.disabled = true;
    ui.conc.disabled = true;

    tokens.length = 0;
    resetStats();
    maintain();
    draw();

    t0 = Date.now();
    const end = t0 + DURATION_MS;
    updateTime(end);
    timerId = setInterval(()=> updateTime(end), 100);
    animId = requestAnimationFrame(tick);
  };

  ui.fsBtn.onclick = async ()=> { await tryFullscreenAndLock(); checkOrientationGate(); await ensureCamera(); };

  ui.stop.onclick = stopSession;

  function stopSession(){
    if (!sessionActive) return;
    sessionActive = false;
    clearInterval(timerId); timerId = null;
    cancelAnimationFrame(animId); animId = null;
    startBtn.disabled = !isLandscape();
    ui.stop.disabled = true;
    ui.diff.disabled = false;
    ui.conc.disabled = false;
    showResults();
  }

  function updateTime(endMs){
    const now = Date.now();
    const remaining = Math.max(0, endMs - now);
    const s = Math.ceil(remaining/1000);
    const mm = String(Math.floor(s/60)).padStart(2,'0');
    const ss = String(s%60).padStart(2,'0');
    ui.time.textContent = `‚è± ${mm}:${ss}`;
    if (remaining <= 0) stopSession();
  }

  function updateHUD(){
    ui.left.textContent = `‚¨ÖÔ∏è L: ${stats.left}`;
    ui.right.textContent = `‚û°Ô∏è R: ${stats.right}`;
    const diff = stats.right - stats.left;
    ui.diffStat.textContent = `Œî R‚àíL: ${diff}`;
    const total = stats.left + stats.right;
    const li = total > 0 ? (diff/total) : 0;
    ui.li.innerHTML = `LI: ${li.toFixed(2)} <small>( (R‚àíL)/(R+L) )</small>`;
  }

  // --- Results & CSV ---
  function showResults(){
    const total = stats.left + stats.right;
    const diff = stats.right - stats.left;
    const li = total > 0 ? (diff/total) : 0;

    const rows = [
      ['Difficulty', ui.diff.value],
      ['Concurrent items', clamp(parseInt(ui.conc.value||6,10),1,12)],
      ['Left taps (L)', stats.left],
      ['Right taps (R)', stats.right],
      ['Difference (R‚àíL)', diff],
      ['Laterality Index (LI)', li.toFixed(3)],
      ['Total taps', total],
      ['Stimuli spawned L/R', `${stats.spawnedLeft} / ${stats.spawnedRight}`],
      ['Stimulus distribution (R%)', totalSpawned() ? ((stats.spawnedRight/totalSpawned())*100).toFixed(1)+'%' : '‚Äî'],
      ['Screen (px)', `${Math.round(window.innerWidth)} √ó ${Math.round(window.innerHeight)} @ DPR ${Math.round((window.devicePixelRatio||1)*100)/100}`],
      ['Orientation', isLandscape() ? 'landscape' : 'portrait'],
    ];
    ui.resultsBody.innerHTML = rows.map(([k,v])=>`<tr><td>${k}</td><td style="text-align:right">${v}</td></tr>`).join('');
    ui.results.style.display = 'flex';
  }

  function totalSpawned(){ return stats.spawnedLeft + stats.spawnedRight; }

  ui.dismissBtn.onclick = ()=> (ui.results.style.display = 'none');

  ui.csvBtn.onclick = ()=>{
    const header = ['time_ms','x','y','side','difficulty','animal'];
    const lines = [
      `# screen_px=${Math.round(window.innerWidth)}x${Math.round(window.innerHeight)}, dpr=${Math.round((window.devicePixelRatio||1)*100)/100}, orientation=${isLandscape()?'landscape':'portrait'}`,
      header.join(',')
    ];
    for (const e of stats.events){
      lines.push([e.t, e.x, e.y, e.side, e.difficulty, `"${e.animal}"`].join(','));
    }
    const blob = new Blob([lines.join('\n')], {type:'text/csv'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    const ts = new Date().toISOString().replace(/[:.]/g,'-');
    a.href = url;
    a.download = `neglect_session_animals_${ui.diff.value}_${ts}.csv`;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 100);
  };

  // --- Orientation enforcement ---
  function isLandscape(){ return window.innerWidth >= window.innerHeight; }
  function checkOrientationGate(){
    const ok = isLandscape();
    ui.orientGate.style.display = ok ? 'none' : 'flex';
    ui.start.disabled = !ok;
    if (!ok && sessionActive) stopSession();
    return ok;
  }
  async function tryFullscreenAndLock(){
    if (!document.fullscreenElement && document.documentElement.requestFullscreen) {
      try { await document.documentElement.requestFullscreen(); } catch(_) {}
    }
    if (screen.orientation && screen.orientation.lock) {
      try { await screen.orientation.lock('landscape'); } catch(_) {}
    }
  }

  // Initial gate check + ResizeObserver
  checkOrientationGate();
  const ro = new ResizeObserver(() => { layout(); if (sessionActive) draw(); });
  ro.observe(cvs);
})();
</script>
</body>
</html>
