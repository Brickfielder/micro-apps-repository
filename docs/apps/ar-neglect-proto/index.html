<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>Neglect Overlay — 1-Minute Screen-Centric Test</title>
<style>
  html, body { height:100%; margin:0; background:#000; overflow:hidden; }
  #wrap { position: fixed; inset: 0; }
  #cam {
    position:absolute; inset:0;
    width:100vw; height:100vh; object-fit: cover;
    transform: translateZ(0);
  }
  #overlay { position:absolute; inset:0; touch-action:none; z-index:10; }
  .midline { position:absolute; top:0; bottom:0; left:50%; width:0; border-left:1px dashed rgba(255,255,255,.25); pointer-events:none; z-index:9; }

  /* HUD bottom-left */
  .hud {
    position: fixed; left: 12px; bottom: 12px; z-index: 20;
    background: rgba(0,0,0,.55); color:#fff; padding: 10px 12px; border-radius: 14px;
    font: 600 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
    backdrop-filter: blur(6px);
  }
  .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  .stat { padding:4px 8px; border:1px solid rgba(255,255,255,.2); border-radius:10px; font-weight:700; }
  .stat small { font-weight:600; opacity:.7; margin-left:6px; }

  /* Controls: vertical stack on right edge */
  .controls {
    position: fixed; right: 12px; top: 12px; z-index: 21;
    display:flex; flex-direction:column; gap:8px; align-items:flex-end;
  }
  .panel {
    background: rgba(0,0,0,.55); color:#fff; padding: 10px 12px; border-radius: 14px;
    font: 600 13px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
    backdrop-filter: blur(6px);
  }
  label { display:flex; align-items:center; gap:6px; font-weight:600; }
  select, input[type=number] {
    appearance:none; background: rgba(255,255,255,.1); color:#fff; border:1px solid rgba(255,255,255,.25);
    border-radius:10px; padding:6px 8px; font: 600 13px/1 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial;
    width: fit-content;
  }
  .btn {
    appearance:none; border:1px solid rgba(255,255,255,.3); background: rgba(255,255,255,.08); color:#fff;
    padding: 8px 12px; border-radius: 12px; font: 700 13px/1 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial;
    cursor:pointer;
  }
  .btn:disabled { opacity: .5; cursor: default; }

  /* Results dialog */
  #results {
    position: fixed; inset: 0; display:none; align-items:center; justify-content:center; z-index: 30;
    background: rgba(0,0,0,.5); backdrop-filter: blur(4px);
  }
  #results .card {
    width:min(92vw, 540px);
    background: rgba(15,15,20,.95); color:#fff; border:1px solid rgba(255,255,255,.1);
    border-radius: 16px; padding: 16px; box-shadow: 0 20px 60px rgba(0,0,0,.5);
    font: 600 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial;
  }
  #results h2 { margin: 0 0 10px; font-size: 18px; }
  #results table { width:100%; border-collapse: collapse; margin: 8px 0 12px; }
  #results td { padding:6px 4px; border-bottom:1px solid rgba(255,255,255,.06); }
  #results .card .actions { display:flex; gap:8px; justify-content:flex-end; margin-top:8px; }
</style>
</head>
<body>
  <div id="wrap">
    <video id="cam" autoplay playsinline muted></video>
    <div class="midline" aria-hidden="true"></div>
    <canvas id="overlay" aria-label="Interaction canvas"></canvas>
  </div>

  <!-- Live HUD (bottom-left) -->
  <div class="hud" id="hud">
    <div class="row">
      <div class="stat" id="time">⏱ 01:00</div>
      <div class="stat" id="leftStat">⬅️ L: 0</div>
      <div class="stat" id="rightStat">➡️ R: 0</div>
      <div class="stat" id="diffStat">Δ R−L: 0</div>
      <div class="stat" id="liStat">LI: 0.00 <small>( (R−L)/(R+L) )</small></div>
    </div>
  </div>

  <!-- Controls (right edge, vertical) -->
  <div class="controls">
    <div class="panel" id="ctlPanel">
      <label>Difficulty
        <select id="difficulty">
          <option value="easy">Easy</option>
          <option value="normal" selected>Normal</option>
          <option value="hard">Difficult</option>
        </select>
      </label>
      <label>Items
        <input id="concurrency" type="number" min="1" max="12" step="1" value="6" />
      </label>
      <div style="display:flex; gap:8px; margin-top:8px;">
        <button class="btn" id="startBtn">Start 1-min</button>
        <button class="btn" id="stopBtn" disabled>Stop</button>
      </div>
    </div>
  </div>

  <!-- Results -->
  <div id="results" role="dialog" aria-modal="true">
    <div class="card">
      <h2>Session results</h2>
      <table><tbody id="resultsBody"></tbody></table>
      <div class="actions">
        <button class="btn" id="csvBtn">Download CSV</button>
        <button class="btn" id="dismissBtn">Close</button>
      </div>
    </div>
  </div>

<script>
(async function(){
  // --- Camera ---
  const cam = document.getElementById('cam');
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: {
        facingMode: { ideal: "environment" },
        width: { ideal: 1280 }, height: { ideal: 720 }, aspectRatio: { ideal: 16/9 }
      }, audio: false
    });
    cam.srcObject = stream;
  } catch (e) {
    alert("Camera access failed: " + e.message);
  }

  // --- Canvas setup ---
  const cvs = document.getElementById('overlay');
  const ctx = cvs.getContext('2d', { alpha: true, desynchronized: true });
  let dpr = Math.max(1, window.devicePixelRatio || 1);

  function layout(){
    cvs.style.width = '100vw'; cvs.style.height = '100vh';
    const r = cvs.getBoundingClientRect();
    cvs.width = Math.round(r.width * dpr);
    cvs.height = Math.round(r.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  layout();
  addEventListener('resize', ()=> setTimeout(layout, 80));
  addEventListener('orientationchange', ()=> setTimeout(layout, 300));

  // --- UI rect helpers (to avoid spawning/overlap) ---
  function rectFrom(el){
    if (!el) return null;
    const cr = cvs.getBoundingClientRect();
    const r = el.getBoundingClientRect();
    return { x1: r.left - cr.left, y1: r.top - cr.top, x2: r.right - cr.left, y2: r.bottom - cr.top };
  }
  function inflate(rect, pad){
    return { x1: rect.x1 - pad, y1: rect.y1 - pad, x2: rect.x2 + pad, y2: rect.y2 + pad };
  }
  function intersects(a,b){
    return !(a.x2 < b.x1 || a.x1 > b.x2 || a.y2 < b.y1 || a.y1 > b.y2);
  }
  function tokenRectAt(x, y, w, h){
    return { x1: x - w/2, y1: y - h/2, x2: x + w/2, y2: y + h/2 };
  }
  function getUIRects(pad=12){
    const hud = rectFrom(document.getElementById('hud'));
    const ctl = rectFrom(document.getElementById('ctlPanel'));
    const arr = [];
    if (hud) arr.push(inflate(hud, pad));
    if (ctl) arr.push(inflate(ctl, pad));
    return arr;
  }

  // --- Parameters & state ---
  const ui = {
    diff: document.getElementById('difficulty'),
    conc: document.getElementById('concurrency'),
    start: document.getElementById('startBtn'),
    stop: document.getElementById('stopBtn'),
    time: document.getElementById('time'),
    left: document.getElementById('leftStat'),
    right: document.getElementById('rightStat'),
    diffStat: document.getElementById('diffStat'),
    li: document.getElementById('liStat'),
    results: document.getElementById('results'),
    resultsBody: document.getElementById('resultsBody'),
    csvBtn: document.getElementById('csvBtn'),
    dismissBtn: document.getElementById('dismissBtn'),
  };

  let tokens = [];
  let sessionActive = false;
  let timerId = null;
  let animId = null;
  let t0 = 0;
  const DURATION_MS = 60_000; // 1 minute fixed

  const stats = {
    left: 0, right: 0, taps: 0,
    spawnedLeft: 0, spawnedRight: 0,
    events: [], // {t,x,y,side,difficulty}
  };

  function resetStats(){
    stats.left = stats.right = stats.taps = 0;
    stats.spawnedLeft = stats.spawnedRight = 0;
    stats.events.length = 0;
    updateHUD();
  }

  function difficultySpec(){
    switch (ui.diff.value) {
      case 'easy':   return { w: 160, h: 100, drift: 0.0, rot: 0.0 };
      case 'normal': return { w: 120, h: 80,  drift: 0.15, rot: 0.002 };
      case 'hard':   return { w: 90,  h: 60,  drift: 0.35, rot: 0.004 };
    }
  }

  // Random spawn that avoids UI rects
  function spawnToken(sideHint = null){
    const r = cvs.getBoundingClientRect();
    const W = r.width, H = r.height;
    const spec = difficultySpec();
    const margin = 24;
    const uiRects = getUIRects(12);

    let tries = 60;
    let x, y;
    while (tries-- > 0){
      // Side-biased x range if hinted
      if (sideHint === 'L') {
        x = margin + spec.w/2 + Math.random() * Math.max(10, (W/2 - margin - spec.w));
        stats.spawnedLeft++;
      } else if (sideHint === 'R') {
        x = (W/2 + margin + spec.w/2) + Math.random() * Math.max(10, (W/2 - margin - spec.w));
        stats.spawnedRight++;
      } else {
        x = margin + spec.w/2 + Math.random() * Math.max(10, (W - (margin + spec.w)));
        if (x < W/2) stats.spawnedLeft++; else stats.spawnedRight++;
      }
      y = margin + spec.h/2 + Math.random() * Math.max(10, (H - (margin + spec.h)));

      const tRect = tokenRectAt(x, y, spec.w, spec.h);
      if (!uiRects.some(u => intersects(tRect, u))) break;
    }

    const hue = Math.floor(Math.random()*360);
    tokens.push({
      x, y, w: spec.w, h: spec.h, s: 1, r: 0,
      hue,
      vx: (Math.random()*2-1) * spec.drift,
      vy: (Math.random()*2-1) * spec.drift,
      vr: (Math.random()*2-1) * spec.rot,
      id: Math.random().toString(36).slice(2),
    });
  }

  function maintain(){
    const target = clamp(parseInt(ui.conc.value||6,10), 1, 12);
    while (tokens.length < target) {
      const side = (stats.spawnedLeft <= stats.spawnedRight) ? 'L' : 'R';
      spawnToken(side);
    }
  }

  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

  // --- Drawing ---
  function drawToken(t){
    ctx.save();
    ctx.translate(t.x, t.y);
    ctx.rotate(t.r);
    // shadow
    ctx.shadowColor = "rgba(0,0,0,0.30)";
    ctx.shadowBlur = 16; ctx.shadowOffsetY = 8;

    // gradient card
    const grd = ctx.createLinearGradient(-t.w/2, -t.h/2, t.w/2, t.h/2);
    grd.addColorStop(0, `hsl(${t.hue} 85% 65%)`);
    grd.addColorStop(1, `hsl(${t.hue} 90% 45%)`);
    roundRect(-t.w/2, -t.h/2, t.w, t.h, 22);
    ctx.fillStyle = grd; ctx.fill();

    // glossy edge
    ctx.shadowBlur = 0;
    ctx.lineWidth = 2; ctx.strokeStyle = "rgba(255,255,255,0.65)";
    ctx.stroke();

    // label
    ctx.fillStyle = "white";
    ctx.font = "700 16px system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial";
    ctx.textAlign = "center"; ctx.textBaseline = "middle";
    ctx.fillText("Tap", 0, -14);
    ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial";
    ctx.fillText("to collect", 0, 8);

    ctx.restore();
  }
  function roundRect(x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function draw(){
    ctx.clearRect(0,0,cvs.width/dpr,cvs.height/dpr);
    for (const t of tokens) drawToken(t);
  }

  // --- Animation (drift + keep off UI + edges) ---
  function tick(){
    const r = cvs.getBoundingClientRect();
    const W = r.width, H = r.height;
    const uiRects = getUIRects(12);

    for (const t of tokens){
      t.x += t.vx; t.y += t.vy; t.r += t.vr;

      // Edge bounce
      const m = 20;
      if (t.x - t.w/2 < m) { t.x = m + t.w/2; t.vx *= -0.9; }
      if (t.x + t.w/2 > W - m) { t.x = W - m - t.w/2; t.vx *= -0.9; }
      if (t.y - t.h/2 < m) { t.y = m + t.h/2; t.vy *= -0.9; }
      if (t.y + t.h/2 > H - m) { t.y = H - m - t.h/2; t.vy *= -0.9; }

      // Avoid UI panels (AABB approx; good enough for small rotations)
      const tr = tokenRectAt(t.x, t.y, t.w, t.h);
      for (const u of uiRects){
        if (intersects(tr, u)){
          // Minimal translation axis push-out
          const dxLeft = Math.abs(tr.x2 - u.x1);
          const dxRight = Math.abs(u.x2 - tr.x1);
          const dyTop = Math.abs(tr.y2 - u.y1);
          const dyBottom = Math.abs(u.y2 - tr.y1);
          const minDelta = Math.min(dxLeft, dxRight, dyTop, dyBottom);
          if (minDelta === dxLeft) { t.x = u.x1 - t.w/2 - 1; t.vx = -Math.abs(t.vx); }
          else if (minDelta === dxRight) { t.x = u.x2 + t.w/2 + 1; t.vx = Math.abs(t.vx); }
          else if (minDelta === dyTop) { t.y = u.y1 - t.h/2 - 1; t.vy = -Math.abs(t.vy); }
          else { t.y = u.y2 + t.h/2 + 1; t.vy = Math.abs(t.vy); }
        }
      }
    }

    maintain();
    draw();
    animId = requestAnimationFrame(tick);
  }

  // --- Interaction ---
  function pickToken(x, y){
    for (let i = tokens.length-1; i >= 0; i--){
      const t = tokens[i];
      // inverse rotate for hit test (approx)
      const dx = x - t.x, dy = y - t.y;
      const c = Math.cos(-t.r), s = Math.sin(-t.r);
      const lx = dx*c - dy*s, ly = dx*s + dy*c;
      if (Math.abs(lx) <= t.w/2 && Math.abs(ly) <= t.h/2) return i;
    }
    return -1;
  }

  cvs.addEventListener('pointerdown', e=>{
    if (!sessionActive) return;
    const rect = cvs.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const i = pickToken(x, y);
    if (i !== -1){
      const side = (x < rect.width/2) ? 'L' : 'R';
      if (side === 'L') stats.left++; else stats.right++;
      stats.taps++;
      stats.events.push({ t: Date.now() - t0, x: Math.round(x), y: Math.round(y), side, difficulty: ui.diff.value });
      tokens.splice(i,1);
      updateHUD();
      draw();
    }
  });

  // --- Session control ---
  ui.start.onclick = ()=>{
    if (sessionActive) return;
    sessionActive = true;
    ui.start.disabled = true;
    ui.stop.disabled = false;
    ui.diff.disabled = true;
    ui.conc.disabled = true;

    tokens.length = 0;
    resetStats();
    maintain();
    draw();

    // timer
    t0 = Date.now();
    const end = t0 + DURATION_MS;
    updateTime(end);
    timerId = setInterval(()=> updateTime(end), 100);

    // animation
    animId = requestAnimationFrame(tick);
  };

  ui.stop.onclick = stopSession;

  function stopSession(){
    if (!sessionActive) return;
    sessionActive = false;
    clearInterval(timerId); timerId = null;
    cancelAnimationFrame(animId); animId = null;
    ui.start.disabled = false;
    ui.stop.disabled = true;
    ui.diff.disabled = false;
    ui.conc.disabled = false;
    showResults();
  }

  function updateTime(endMs){
    const now = Date.now();
    const remaining = Math.max(0, endMs - now);
    const s = Math.ceil(remaining/1000);
    const mm = String(Math.floor(s/60)).padStart(2,'0');
    const ss = String(s%60).padStart(2,'0');
    ui.time.textContent = `⏱ ${mm}:${ss}`;
    if (remaining <= 0) stopSession();
  }

  function updateHUD(){
    ui.left.textContent = `⬅️ L: ${stats.left}`;
    ui.right.textContent = `➡️ R: ${stats.right}`;
    const diff = stats.right - stats.left;
    ui.diffStat.textContent = `Δ R−L: ${diff}`;
    const total = stats.left + stats.right;
    const li = total > 0 ? (diff/total) : 0;
    ui.li.innerHTML = `LI: ${li.toFixed(2)} <small>( (R−L)/(R+L) )</small>`;
  }

  // --- Results & CSV ---
  function showResults(){
    const total = stats.left + stats.right;
    const diff = stats.right - stats.left;
    const li = total > 0 ? (diff/total) : 0;

    const rows = [
      ['Difficulty', ui.diff.value],
      ['Concurrent items', clamp(parseInt(ui.conc.value||6,10),1,12)],
      ['Left taps (L)', stats.left],
      ['Right taps (R)', stats.right],
      ['Difference (R−L)', diff],
      ['Laterality Index (LI)', li.toFixed(3)],
      ['Total taps', total],
      ['Stimuli spawned L/R', `${stats.spawnedLeft} / ${stats.spawnedRight}`],
      ['Stimulus distribution (R%)', totalSpawned() ? ((stats.spawnedRight/totalSpawned())*100).toFixed(1)+'%' : '—'],
    ];
    ui.resultsBody.innerHTML = rows.map(([k,v])=>`<tr><td>${k}</td><td style="text-align:right">${v}</td></tr>`).join('');
    ui.results.style.display = 'flex';
  }

  function totalSpawned(){ return stats.spawnedLeft + stats.spawnedRight; }

  ui.dismissBtn.onclick = ()=> (ui.results.style.display = 'none');

  ui.csvBtn.onclick = ()=>{
    const header = ['time_ms','x','y','side','difficulty'];
    const lines = [header.join(',')];
    for (const e of stats.events){
      lines.push([e.t, e.x, e.y, e.side, e.difficulty].join(','));
    }
    const blob = new Blob([lines.join('\n')], {type:'text/csv'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    const ts = new Date().toISOString().replace(/[:.]/g,'-');
    a.href = url;
    a.download = `neglect_session_${ui.diff.value}_${ts}.csv`;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 100);
  };

  // Keep layout + token safety fresh when UI size changes
  const ro = new ResizeObserver(() => {
    layout();
    if (sessionActive) { draw(); }
  });
  ro.observe(cvs);
})();
</script>
</body>
</html>