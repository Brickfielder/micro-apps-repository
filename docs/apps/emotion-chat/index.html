<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Emotion Chat — Social Cognition Micro-App</title>

  <!-- Tell frame.js which app we are; it will inject the hero from catalog.json -->
  <meta name="app-slug" content="emotion_chat"/>
  <!-- Optional overrides if you want to force a custom title/desc
  <meta name="app-title" content="Emotion Chat">
  <meta name="app-desc" content="WhatsApp-style scenarios to practice emotion recognition, theory of mind, and social reasoning.">
  -->
  <!-- Opt-in styling toggles used across Barista/Audio Errands -->
  <meta name="theme" content="bold dense">

  <!-- Shared assets (redundant but resilient; frame.js will also ensure CSS) -->
  <link rel="stylesheet" href="/shared/theme.css">
  <link rel="stylesheet" href="/docs/shared/theme.css">
  <script defer src="/shared/frame.js"></script>
  <script defer src="/docs/shared/frame.js"></script>
  <script defer src="/shared/clinician_feedback.js"></script>
  <script defer src="/docs/shared/clinician_feedback.js"></script>

  <style>
    /* ===== App-local styles: minimal, lean on shared theme ===== */

    /* Compact toolbar like Barista/Audio Errands */
    .toolbar label{ margin:0 .25rem 0 0; font-weight:600; }
    .toolbar .ctrl{ display:inline-grid; gap:.35rem; }

    /* Two-column content area inside #app-root */
    .app-grid{ display:grid; gap:clamp(12px,1.2vw,18px); grid-template-columns: 1fr 1fr; }
    @media (max-width: 980px){ .app-grid{ grid-template-columns: 1fr; } }

    .card{
      background: var(--surface);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: clamp(14px, 1.6vw, 18px);
    }
    .card h2{ margin:0 0 .5rem; }

    /* Chat window */
    .chat{
      background: color-mix(in oklab, var(--surface), var(--line) 10%);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 12px;
      height: 520px;
      overflow:auto;
    }
    .bubble{
      max-width: 78%;
      padding: 10px 12px;
      border-radius: 14px;
      margin: 10px 0;
      display:inline-block;
      word-wrap:break-word;
      box-shadow: 0 2px 8px rgba(0,0,0,.06);
      font-size: clamp(15px, 1.4vw, 16px);
    }
    .fromA{ background: #fff; border:1px solid color-mix(in oklab, var(--line), #000 0%); }
    .fromB{ background: color-mix(in oklab, var(--accent), white 85%); border:1px solid color-mix(in oklab, var(--accent), var(--line) 75%); }
    .name{ display:block; font-size:.9rem; color: var(--muted); margin-bottom:4px }

    .footer{ display:flex; gap:10px; justify-content:space-between; align-items:center; margin-top:8px }
    .small{ color: var(--muted); font-size:.95rem; }

    /* Steps */
    .step{ background: var(--surface); border:1px solid var(--line); border-radius:12px; padding:12px }
    .row{ display:grid; gap:12px; grid-template-columns: 1fr 1fr; }
    @media (max-width: 720px){ .row{ grid-template-columns: 1fr; } }
    textarea{ width:100%; min-height:120px; resize:vertical; }
    .legend{ color: var(--muted); }

    /* Pills (use shared .pill shape, add interactive bits) */
    .pillgrid{ display:grid; grid-template-columns: repeat(auto-fill, minmax(160px,1fr)); gap:10px; }
    .pill-btn{
      display:inline-flex; align-items:center; justify-content:center;
      min-height: 42px; padding: 10px 14px; border-radius: 999px; border:1px solid var(--line);
      background:#f2f4f7; cursor:pointer; font-weight:600; transition: transform .06s ease;
    }
    .pill-btn:active{ transform: scale(.98) }
    .pill-btn[aria-pressed="true"]{ background: var(--accent); color:#fff; border-color: var(--accent-600); }

    /* Feedback tags */
    .tags{ display:flex; gap:8px; flex-wrap:wrap; margin-top:8px }
    .tag.good{ border:1px solid #b7e3c4; background:#ecfdf5; color:#065f46; border-radius:999px; padding:6px 10px; }
    .tag.bad { border:1px solid #f6c7c7; background:#fef2f2; color:#7f1d1d; border-radius:999px; padding:6px 10px; }

    /* Divider */
    .divider{ height:1px; background: var(--line); margin:10px 0; }
  </style>
</head>
<body>
  <!-- frame.js will wrap this in .app-wrap and inject a .app-hero above -->
  <main id="app-root">
    <!-- Controls bar -->
    <div class="toolbar" role="region" aria-label="Controls">
      <div class="ctrl">
        <label for="scenario">Scenario</label>
        <select id="scenario"></select>
      </div>
      <div class="ctrl">
        <label for="distractors">Distractors per person</label>
        <select id="distractors">
          <option>6</option><option selected>8</option><option>10</option><option>12</option><option>14</option>
        </select>
      </div>

      <button class="button primary" id="play">Play chat</button>
      <button class="button" id="skip" disabled>Skip chat</button>
      <button class="button" id="reset" disabled>Reset</button>
      <a class="button" id="download" download="emotion_chat_results.csv" title="Download CSV of your results" href="#" aria-disabled="true">Download CSV</a>
      <span class="small" id="status" aria-live="polite"></span>
    </div>

    <!-- App grid -->
    <div class="app-grid">
      <!-- Left: Chat -->
      <section class="card" aria-labelledby="chatTitle">
        <h2 id="chatTitle">Chat</h2>
        <div id="chat" class="chat" aria-label="Chat transcript" aria-live="polite"></div>
        <div class="footer">
          <span class="small" id="progress">0 / 0</span>
          <span class="small" id="timerText"></span>
        </div>
      </section>

      <!-- Right: Steps -->
      <section class="card" aria-labelledby="respTitle">
        <h2 id="respTitle">Your responses</h2>

        <div class="step" id="step1">
          <h3>Step 1 — Free choice</h3>
          <div class="row">
            <div>
              <label class="legend" for="freeA" id="labelA"></label>
              <textarea id="freeA" placeholder="Type one or more emotions…"></textarea>
            </div>
            <div>
              <label class="legend" for="freeB" id="labelB"></label>
              <textarea id="freeB" placeholder="Type one or more emotions…"></textarea>
            </div>
          </div>
          <div class="divider"></div>
          <button class="button primary" id="proceed" disabled>Continue to Step 2</button>
          <span class="small" id="step1Hint">Finish the chat, then fill both boxes to proceed.</span>
        </div>

        <div class="step" id="step2" hidden>
          <h3>Step 2 — Select emotions (choose all that apply)</h3>
          <div class="row" style="grid-template-columns:1fr 1fr">
            <div>
              <div class="legend" id="pillTitleA"></div>
              <div class="pillgrid" id="pillsA"></div>
            </div>
            <div>
              <div class="legend" id="pillTitleB"></div>
              <div class="pillgrid" id="pillsB"></div>
            </div>
          </div>
          <div class="divider"></div>
          <button class="button primary" id="submit" disabled>Show feedback</button>
        </div>

        <div class="step" id="step3" hidden>
          <h3>Step 3 — Feedback</h3>
          <div class="feedback" id="fbA"></div>
          <div class="feedback" id="fbB"></div>
          <div class="tags" id="kpi"></div>
        </div>
      </section>
    </div>
  </main>

  <script>
  /* ========= Global master list ========= */
  const MASTER_PILLS = [
    "Happy","Excited","Frustrated","Irritated","Calm","Disappointed","Guilty","Sad","Defensive","Anxious",
    "Embarrassed","Angry","Relieved","Neutral","Confused","Optimistic","Proud","Distant","Supportive",
    "Jealous","Envious","Hurt","Curious","Content","Resentful","Surprised","Hopeful",
    "Grateful","Appreciative","Concerned","Bored","Regretful","Apathetic"
  ];

  /* ========= Scenarios (unchanged) ========= */
  const SCENARIOS = /* (keep your full scenarios array here) */ <?php /* placeholder if templating */ ?>;
  // For plain HTML use the full SCENARIOS array from your original code:
  // --- START SCENARIOS COPY ---
  const SCENARIOS_DATA = <?/* paste your SCENARIOS array JSON here if you prefer keeping code cleaner */?>;
  // --- END SCENARIOS COPY ---
  // If not using a separate SCENARIOS_DATA, just replace all SCENARIOS references below with your SCENARIOS array.

  /* ========= State ========= */
  let current=null, timer=null, idx=0, revealed=false, startTime=0, endTime=0;
  let RESULTS=[];
  const $ = id => document.getElementById(id);

  const chatEl = $("chat"), scenarioSel = $("scenario");
  const playBtn = $("play"), skipBtn = $("skip"), resetBtn = $("reset");
  const statusEl = $("status"), progressEl = $("progress"), chatTitle = $("chatTitle"), timerText = $("timerText");
  const step1 = $("step1"), proceedBtn = $("proceed"), step1Hint = $("step1Hint");
  const step2 = $("step2"), submitBtn = $("submit"), step3 = $("step3");
  const freeA = $("freeA"), freeB = $("freeB");
  const labelA = $("labelA"), labelB = $("labelB");
  const pillTitleA = $("pillTitleA"), pillTitleB = $("pillTitleB");
  const pillsA = $("pillsA"), pillsB = $("pillsB");
  const fbA = $("fbA"), fbB = $("fbB"), kpi = $("kpi");
  const distractorsSel = $("distractors");
  const downloadA = $("download");

  /* ========= Helpers ========= */
  function clearChat(){ chatEl.innerHTML=""; }
  function addBubble(from,name,text){
    const wrap=document.createElement("div");
    const b=document.createElement("div");
    const who=document.createElement("span");
    who.className="name"; who.textContent=name;
    b.className="bubble "+(from==="A"?"fromA":"fromB");
    b.innerText=text; wrap.appendChild(who); wrap.appendChild(b);
    wrap.style.textAlign = from==="A"?"left":"right";
    chatEl.appendChild(wrap); chatEl.scrollTop=chatEl.scrollHeight;
  }
  function setDisabled(el,v){
    if (el.tagName === "A") {
      el.setAttribute("aria-disabled", v ? "true" : "false");
      el.classList.toggle("disabled", !!v);
    } else {
      el.toggleAttribute("disabled", !!v);
    }
  }
  function shuffle(arr){ return [...arr].sort(()=>Math.random()-0.5); }

  function secondsSince(t0){ return Math.round((Date.now()-t0)/1000); }
  let tickInt=null;
  function startTick(){ stopTick(); tickInt=setInterval(()=>{ timerText.textContent=`Time: ${secondsSince(startTime)}s`; }, 1000); }
  function stopTick(){ if(tickInt){ clearInterval(tickInt); tickInt=null; } }

  /* ========= Build UI ========= */
  function populateScenarioList(){
    scenarioSel.innerHTML="";
    SCENARIOS.forEach(s=>{ const opt=document.createElement("option"); opt.value=s.id; opt.textContent=s.title; scenarioSel.appendChild(opt); });
  }
  function loadScenario(id){
    current = SCENARIOS.find(s=>s.id===id) || SCENARIOS[0];
    idx=0; revealed=false; startTime=0; endTime=0;
    clearInterval(timer); timer=null; clearChat(); step3.hidden=true;
    progressEl.textContent = `0 / ${current.messages.length}`;
    timerText.textContent = "";
    chatTitle.textContent = `Chat — ${current.people.A} & ${current.people.B}`;
    statusEl.textContent = "Ready";
    setDisabled(playBtn,false); setDisabled(skipBtn,true); setDisabled(resetBtn,true);
    setDisabled(downloadA, RESULTS.length===0);

    // Step 1 reset
    freeA.value=""; freeB.value="";
    labelA.textContent=`What emotions was ${current.people.A} feeling?`;
    labelB.textContent=`What emotions was ${current.people.B} feeling?`;

    // Step 2 hidden until Step 1 completed
    step2.hidden=true; submitBtn.disabled=true;
    pillTitleA.textContent = `Select all that apply for ${current.people.A}`;
    pillTitleB.textContent = `Select all that apply for ${current.people.B}`;

    // Pre-build pills
    buildPills();
    updateProceedState();
  }
  function buildPills(){
    const N = parseInt(distractorsSel.value, 10) || 8;

    const makeGrid = (correctArr)=>{
      const correctSet = new Set(normalise(correctArr));
      const candidates = MASTER_PILLS.filter(p=>!correctSet.has(normalise([p])[0]));
      const distractors = shuffle(candidates).slice(0, Math.max(0,N));
      const final = shuffle([...new Set([...correctArr, ...distractors])]);
      return final;
    };

    const listA = makeGrid(current.correct.A);
    const listB = makeGrid(current.correct.B);

    pillsA.innerHTML=""; pillsB.innerHTML="";
    for(const label of listA){
      const b=document.createElement("button");
      b.className="pill-btn"; b.type="button"; b.textContent=label; b.setAttribute("aria-pressed","false");
      b.addEventListener("click", ()=>{ togglePill(b); updateSubmitState(); });
      pillsA.appendChild(b);
    }
    for(const label of listB){
      const b=document.createElement("button");
      b.className="pill-btn"; b.type="button"; b.textContent=label; b.setAttribute("aria-pressed","false");
      b.addEventListener("click", ()=>{ togglePill(b); updateSubmitState(); });
      pillsB.appendChild(b);
    }
  }
  function togglePill(el){
    const pressed=el.getAttribute("aria-pressed")==="true";
    el.setAttribute("aria-pressed", String(!pressed));
  }
  function updateProceedState(){
    const filled = freeA.value.trim().length>0 && freeB.value.trim().length>0;
    setDisabled(proceedBtn, !(filled && revealed));
    step1Hint.textContent = revealed
      ? (filled ? "Ready." : "Fill both boxes to proceed.")
      : "Finish the chat, then fill both boxes to proceed.";
  }
  function updateSubmitState(){
    const aChosen = !!pillsA.querySelector('.pill-btn[aria-pressed="true"]');
    const bChosen = !!pillsB.querySelector('.pill-btn[aria-pressed="true"]');
    setDisabled(submitBtn, !(aChosen && bChosen));
  }

  /* ========= Playback ========= */
  function playChat(){
    if(!current) return;
    setDisabled(playBtn,true); setDisabled(skipBtn,false); setDisabled(resetBtn,false);
    statusEl.textContent="Playing…"; startTime=Date.now(); startTick();
    timer=setInterval(()=>{
      if(idx>=current.messages.length){ finishChat(); return; }
      const m=current.messages[idx++]; addBubble(m.from,current.people[m.from],m.text);
      progressEl.textContent=`${idx} / ${current.messages.length}`;
      if(idx>=current.messages.length){ finishChat(); }
    }, 3500);
  }
  function finishChat(){
    clearInterval(timer); timer=null; setDisabled(skipBtn,true); endTime=Date.now(); stopTick();
    statusEl.textContent="Chat complete — do Step 1"; revealed=true; updateProceedState();
  }
  function skipChat(){
    if(!current) return; if(!startTime){ startTime=Date.now(); startTick(); }
    clearInterval(timer); timer=null;
    for(; idx<current.messages.length; idx++){ const m=current.messages[idx]; addBubble(m.from,current.people[m.from],m.text); }
    progressEl.textContent=`${current.messages.length} / ${current.messages.length}`;
    finishChat();
  }
  function resetAll(){ loadScenario(scenarioSel.value); }

  /* ========= Step transitions ========= */
  $("proceed").addEventListener("click", ()=>{ step2.hidden = false; const first = pillsA.querySelector('.pill-btn'); if(first) first.focus(); });

  /* ========= Normalisation / Feedback ========= */
  function normalise(arr){
    return arr.map(x=>{
      const t = (x||"").toString().trim().toLowerCase();
      if(t==="withdrawn") return "Sad";
      if(t==="jealousy") return "Jealous";
      if(t==="envy") return "Envious";
      if(t==="thankful") return "Grateful";
      if(t==="anxiety") return "Anxious";
      if(t==="worry") return "Concerned";
      return x;
    });
  }
  function computeFeedback(){
    const selA=[...pillsA.querySelectorAll('.pill-btn[aria-pressed="true"]')].map(b=>b.textContent);
    const selB=[...pillsB.querySelectorAll('.pill-btn[aria-pressed="true"]')].map(b=>b.textContent);
    const corrA=current.correct.A, corrB=current.correct.B;

    const S=a=>new Set(a);
    const aSet=S(normalise(selA)), cA=S(normalise(corrA));
    const bSet=S(normalise(selB)), cB=S(normalise(corrB));

    const aHits=[...aSet].filter(x=>cA.has(x)), aMiss=[...cA].filter(x=>!aSet.has(x)), aExtra=[...aSet].filter(x=>!cA.has(x));
    const bHits=[...bSet].filter(x=>cB.has(x)), bMiss=[...cB].filter(x=>!bSet.has(x)), bExtra=[...bSet].filter(x=>!cB.has(x));

    const prec=(hits,picks)=>picks===0?0:Math.round((hits/picks)*100);
    const rec =(hits,total)=>total===0?0:Math.round((hits/total)*100);

    const aPrec=prec(aHits.length, selA.length), aRec=rec(aHits.length, corrA.length);
    const bPrec=prec(bHits.length, selB.length), bRec=rec(bHits.length, corrB.length);

    fbA.innerHTML = `
      <strong>${current.people.A}</strong><br/>
      <span class="small">Correct:</span> ${corrA.join(", ")}<br/>
      <span class="small">You selected:</span> ${selA.join(", ") || "—"}<br/>
      <div class="small" style="margin-top:6px">${current.cues.A}</div>
      <div class="small" style="margin-top:6px;color:${aExtra.length?'#7f1d1d':'#065f46'}">
        Hits: ${aHits.join(", ")||"—"} | Missed: ${aMiss.join(", ")||"—"} | Extra: ${aExtra.join(", ")||"—"}
      </div>
    `;
    fbB.innerHTML = `
      <strong>${current.people.B}</strong><br/>
      <span class="small">Correct:</span> ${corrB.join(", ")}<br/>
      <span class="small">You selected:</span> ${selB.join(", ") || "—"}<br/>
      <div class="small" style="margin-top:6px">${current.cues.B}</div>
      <div class="small" style="margin-top:6px;color:${bExtra.length?'#7f1d1d':'#065f46'}">
        Hits: ${bHits.join(", ")||"—"} | Missed: ${bMiss.join(", ")||"—"} | Extra: ${bExtra.join(", ")||"—"}
      </div>
    `;
    kpi.innerHTML = `
      <span class="tag ${aRec>=75?'good':'bad'}">${current.people.A} — Recall ${aRec}%</span>
      <span class="tag ${aPrec>=75?'good':'bad'}">${current.people.A} — Precision ${aPrec}%</span>
      <span class="tag ${bRec>=75?'good':'bad'}">${current.people.B} — Recall ${bRec}%</span>
      <span class="tag ${bPrec>=75?'good':'bad'}">${current.people.B} — Precision ${bPrec}%</span>
    `;
    step3.hidden=false;

    // Save result row
    const durationSec = Math.max(0, Math.round(((endTime||Date.now()) - (startTime||Date.now()))/1000));
    RESULTS.push({
      scenario_id: current.id,
      scenario_title: current.title,
      personA: current.people.A,
      personB: current.people.B,
      freeA: freeA.value.replace(/\s+/g,' ').trim(),
      freeB: freeB.value.replace(/\s+/g,' ').trim(),
      selectedA: selA.join('; '),
      selectedB: selB.join('; '),
      hitsA: aHits.join('; '),
      hitsB: bHits.join('; '),
      missedA: aMiss.join('; '),
      missedB: bMiss.join('; '),
      extraA: aExtra.join('; '),
      extraB: bExtra.join('; '),
      precisionA: aPrec, recallA: aRec,
      precisionB: bPrec, recallB: bRec,
      distractors_per_person: parseInt(distractorsSel.value,10),
      duration_s: durationSec,
      timestamp: new Date().toISOString()
    });
    setDisabled(downloadA, RESULTS.length===0);
  }

  /* ========= CSV ========= */
  function toCSV(rows){
    const headers = Object.keys(rows[0]);
    const escape = v => `"${String(v??'').replace(/"/g,'""')}"`;
    const lines = [headers.join(',')].concat(rows.map(r => headers.map(h=>escape(r[h])).join(',')));
    return lines.join('\n');
  }

  function triggerCSVDownload(csvText, filename){
    const blob = new Blob([csvText], {type:"text/csv;charset=utf-8;"});
    const url = URL.createObjectURL(blob);
    downloadA.href = url;
    downloadA.setAttribute("download", filename || "emotion_chat_results.csv");
    // clinician_feedback.js will intercept this click and append clinician_comment
    downloadA.click();
    setTimeout(()=>URL.revokeObjectURL(url), 1000);
  }

  function handleDownload(){
    if(RESULTS.length===0) return;
    const csv = toCSV(RESULTS);
    triggerCSVDownload(csv, "emotion_chat_results.csv");
  }

  /* ========= Events ========= */
  scenarioSel.addEventListener("change", e=>loadScenario(e.target.value));
  distractorsSel.addEventListener("change", ()=>{ buildPills(); });
  playBtn.addEventListener("click", playChat);
  skipBtn.addEventListener("click", skipChat);
  resetBtn.addEventListener("click", resetAll);
  downloadA.addEventListener("click", (e)=>{ 
    if(RESULTS.length===0){ e.preventDefault(); return; }
    // If href is already set (blob), let clinician_feedback.js augment; otherwise build now
    if(!downloadA.href || downloadA.href === "#"){ e.preventDefault(); handleDownload(); }
  });
  $("proceed").addEventListener("click", ()=>{/* handled above */});
  $("submit").addEventListener("click", computeFeedback);
  freeA.addEventListener("input", updateProceedState);
  freeB.addEventListener("input", updateProceedState);

  /* ========= Init ========= */
  populateScenarioList();
  loadScenario(SCENARIOS[0].id);
  </script>

  <!-- Clinician note card is injected by clinician_feedback.js; no inline HTML needed -->
</body>
</html>
