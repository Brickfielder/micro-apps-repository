<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>

  <title>Maze Explorer — Anchor Latency, Metrics, Idle Timer</title>

  <!-- Identify the app for the shared frame -->
  <meta name="app-slug" content="maze-explorer">
  <!-- Page-level overrides (shown in the hero) -->
  <meta name="app-title" content="Maze Explorer">
  <meta name="app-desc" content="Start bottom-right, reach the yellow goal at top-left. Anchor every 10 moves; coach warns on wrong turns. Idle-aware active timer + CSV stats.">
  <!-- Optional toggles: 'bold' and/or 'dense' -->
  <meta name="theme" content="bold">

  <!-- Shared assets published from repo/docs/ as site root -->
  <link rel="stylesheet" href="/micro-apps-repository/shared/theme.css?v=3">
  <script defer src="/micro-apps-repository/shared/frame.js?v=3"></script>
  <script defer src="/micro-apps-repository/shared/clinician_feedback.js?v=3"></script>

  <style>
    /* App-specific minimal styles; layout & typography come from shared theme */
    :root{
      --green:#2E8B57;
      --dark:#1c6640;
      --anchor:#d62828;
      --goal:#ffd166;
      --player:#4682B4;
      --coach:#ffe8ed;
      --coachBorder:#ef476f;
      --info:#0b7285;
    }
    #rules.callout{
      border-left:5px solid var(--green);
    }
    .wrap{
  position: relative;
  display: flex;
  align-items: flex-start;
  gap: 12px;

  /* Center the red anchor + canvas block */
  justify-content: center;        /* ⟵ key line */
  margin: 12px auto 0;            /* auto side margins to center the block */
  width: fit-content;              /* shrink-wrap to content */
  max-width: 100%;                 /* don’t overflow on small screens */
}
    #leftAnchor.flash{ animation: flash 0.5s ease-in-out 3; }
    @keyframes flash { 50%{ filter:brightness(1.4);} }

    #mazeCanvas{
      touch-action:none; background:#fff;
      border:4px solid var(--green);
      box-shadow:0 0 10px rgba(0,0,0,0.1);
      max-width:100%;
      height:auto;
    }

    #coach{
      position:absolute; display:none; z-index:10;
      background:var(--coach); border:3px solid var(--coachBorder);
      border-radius:12px; padding:14px 16px; width:min(260px, 40vw);
      box-shadow:0 10px 24px rgba(0,0,0,.25);
      font-size:16px; line-height:1.3;
    }
    #coach b{ color:#b30038; }

    #anchorTip{ color:#a00; font-weight:600; display:none; }
    #statusBar, #logBar, #metrics{ color: var(--text); }

    /* Make buttons adopt theme styles */
    .dir-btn{ width:60px; height:60px; font-size:24px; }
    .dir-grid{ display:grid; grid-template-columns: repeat(4, 60px); gap:10px; justify-content:center; }

    /* Responsive sizing for canvas/anchor on small screens */
    @media (max-width: 720px){
      #leftAnchor{ height:64vw; }
      #mazeCanvas{ width:90vw; height:90vw; }
      #coach{ width:54vw; font-size:15px; }
      .dir-btn{ width:54px; height:54px; font-size:22px; }
      .dir-grid{ grid-template-columns: repeat(4, 54px); }
    }
  </style>
</head>

<body>
  <!-- The hero header is injected above this by frame.js -->
  <main id="app-root" role="main" aria-labelledby="app-title">

    <!-- Collapsible instructions (repo style) -->
    <details class="note-card" open>
      <summary><strong>How it works</strong></summary>
      <div id="rules" class="callout" style="margin-top:12px">
        <p><b>Task:</b> Find your way from the <u>bottom-right</u> start square to the <u>top-left</u> yellow goal.</p>
        <p><b>Rules:</b> Swipe the grid or use the arrow buttons. Every <b>10 moves</b>, tap the
          <span style="color:#d62828"><b>red left anchor</b></span> before continuing. If the <b>coach panel</b> appears,
          you may be moving away — <b>tap the panel to close</b> and consider backtracking.</p>
        <p><b>Timing:</b> The timer counts only <i>active time</i>. If there’s no move or anchor tap for <b>30s</b>,
          timing pauses automatically and resumes on the next action.</p>
      </div>
    </details>

    <!-- Toolbar -->
    <div class="toolbar" style="justify-content:center">
      <label for="difficulty" style="margin:0">Difficulty</label>
      <select id="difficulty" aria-label="Select difficulty" style="max-width:14rem">
        <option value="10">Easy (10×10)</option>
        <option value="16">Medium (16×16)</option>
        <option value="20">Hard (20×20)</option>
      </select>
      <span class="pill" id="idleBadge" style="display:none">Paused — no activity</span>
    </div>

    <!-- Game area -->
    <div class="wrap" id="wrap" style="margin-top:12px">
      <div id="leftAnchor" title="Tap here to re-anchor left" aria-label="Left anchor" role="button" tabindex="0"></div>
      <canvas id="mazeCanvas" width="520" height="520" aria-label="Maze grid"></canvas>
      <div id="coach" role="alert">You might be moving away from the goal on the right. <b>Tap to close</b> and try backtracking.</div>
    </div>

    <p id="anchorTip" class="helper">Touch the <b>red left anchor</b> to continue.</p>

    <!-- Directional controls -->
    <div class="dir-grid" aria-label="Directional controls">
      <button id="up" class="button dir-btn" aria-label="Move up">↑</button>
      <button id="left" class="button dir-btn" aria-label="Move left">←</button>
      <button id="down" class="button dir-btn" aria-label="Move down">↓</button>
      <button id="right" class="button dir-btn" aria-label="Move right">→</button>
    </div>

    <div id="statusBar" class="helper" style="margin-top:10px"></div>

    <div id="logBar" style="display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-top:8px">
      <button id="downloadBtn" class="button primary">Download stats (CSV)</button>
      <!-- reset button is injected next to this in JS -->
    </div>

    <div id="metrics" class="note-card" style="margin-top:8px; border-left:5px solid var(--info)">
      Completed mazes: <b><span id="mCompleted">0</span></b>
      &nbsp;|&nbsp; Active time on this device: <b><span id="mActive">00:00:00</span></b>
    </div>

    <!-- JS: unchanged game logic, lightly adapted to the new structure -->
    <script>
    (function(){
      // ===== Config =====
      const ANCHOR_INTERVAL = 10;
      const WRONG_TURN_THRESHOLD = 5;
      const IDLE_MS = 30000;

      // ===== DOM =====
      const wrap = document.getElementById('wrap');
      const canvas = document.getElementById('mazeCanvas');
      const ctx = canvas.getContext('2d');
      const leftAnchorEl = document.getElementById('leftAnchor');
      const coach = document.getElementById('coach');
      const anchorTip = document.getElementById('anchorTip');
      const statusBar = document.getElementById('statusBar');
      const downloadBtn = document.getElementById('downloadBtn');
      const difficultySel = document.getElementById('difficulty');
      const mCompletedEl = document.getElementById('mCompleted');
      const mActiveEl = document.getElementById('mActive');
      const idleBadge = document.getElementById('idleBadge');

      // Add the "Try a new maze" button (absolute within wrap)
      let newMazeBtn = document.createElement('button');
      newMazeBtn.id = 'newMazeBtn';
      newMazeBtn.textContent = 'Try a new maze';
      newMazeBtn.className = 'button primary';
      newMazeBtn.style.position = 'absolute';
      newMazeBtn.style.display = 'none';
      wrap.style.position = 'relative';
      wrap.appendChild(newMazeBtn);

      // ===== Metrics (localStorage) =====
      const METRIC_KEY = 'maze_metrics_v1';
      function loadMetrics(){
        try { return JSON.parse(localStorage.getItem(METRIC_KEY)) || {totalActiveMs:0, totalCompletions:0}; }
        catch(e){ return {totalActiveMs:0, totalCompletions:0}; }
      }
      function saveMetrics(m){ localStorage.setItem(METRIC_KEY, JSON.stringify(m)); }
      let metrics = loadMetrics();
      function fmtTime(ms){
        let s = Math.floor(ms/1000);
        const h = Math.floor(s/3600); s%=3600;
        const m = Math.floor(s/60); s%=60;
        const pad = n=>String(n).padStart(2,'0');
        return `${pad(h)}:${pad(m)}:${pad(s)}`;
      }
      let liveAccumMs = 0;
      function refreshMetricUI(){
        mCompletedEl.textContent = metrics.totalCompletions;
        mActiveEl.textContent = fmtTime(metrics.totalActiveMs + liveAccumMs);
      }

      // ===== Game state =====
      let rows=10, cols=10;
      let cellSize = canvas.width / cols;
      let grid=null, distMap=null;
      let player={i:0, j:0};
      let tapCount=0, anchorNeeded=false, wrongProgress=0, lastDist=Infinity;

      // Track anchor latency
      let lastAnchorRequiredAt = null;

      // ===== Active time tracking with idle pause =====
      let active=false;
      let lastMoveAt = Date.now();
      let lastActiveStart = Date.now();
      let tickTimer = null;
      let mazeLiveAccumMs = 0;

      let currentMaze = null;
      let mazeCompleted = false;
      let mazeStats = [];
      let mazeIndex = 0;

      function setActive(val){
        if(val===active) return;
        active = val;
        if(active){
          lastActiveStart = Date.now();
          idleBadge.style.display='inline-block';
          idleBadge.textContent = 'Active';
          ensureTicker();
          logEvent('active_resume');
        }else{
          const now = Date.now();
          const pauseAt = lastMoveAt + IDLE_MS;
          const end = Math.min(now, pauseAt);
          const delta = Math.max(0, end - lastActiveStart);
          metrics.totalActiveMs += liveAccumMs;
          liveAccumMs = 0;
          if(currentMaze && !mazeCompleted){
            currentMaze.activeMs += mazeLiveAccumMs;
          }
          mazeLiveAccumMs = 0;
          saveMetrics(metrics);
          refreshMetricUI();
          idleBadge.style.display='inline-block';
          idleBadge.textContent = 'Paused — no activity';
          logEvent('active_pause');
        }
      }

      function ensureTicker(){
        if(tickTimer) return;
        tickTimer = setInterval(()=>{
          if(!active) return;
          const now = Date.now();
          const pauseAt = lastMoveAt + IDLE_MS;
          const end = Math.min(now, pauseAt);
          const delta = Math.max(0, end - lastActiveStart);
          liveAccumMs += delta;
          if(currentMaze && !mazeCompleted){
            mazeLiveAccumMs += delta;
          }
          lastActiveStart = end;
          refreshMetricUI();
          if(now >= pauseAt){
            setActive(false);
          }
        }, 1000);
      }

      function markActivity(){
        const now = Date.now();
        lastMoveAt = now;
        if(!active) {
          lastActiveStart = now;
          setActive(true);
        }
      }

      document.addEventListener('visibilitychange', ()=>{ if(document.hidden) setActive(false); });

      // ===== Session log (minimal) =====
      const sessionStart = Date.now();
      const log = [];
      function logEvent(type, data={}){ log.push({t: Date.now() - sessionStart, type, ...data}); }

      function finalizeCurrentMazeForStats(){
        if(!currentMaze) return;
        const now = Date.now();
        const pauseAt = lastMoveAt + IDLE_MS;
        const end = Math.min(now, pauseAt);
        const delta = Math.max(0, end - lastActiveStart);
        liveAccumMs += delta;
        if(!mazeCompleted){ mazeLiveAccumMs += delta; }
        lastActiveStart = end;
        currentMaze.activeMs += mazeLiveAccumMs;
        mazeLiveAccumMs = 0;
        const meanLatency = currentMaze.anchorLatencyCount > 0
          ? Math.round(currentMaze.anchorLatencySum / currentMaze.anchorLatencyCount)
          : '';
        mazeStats.push({
          index: currentMaze.index,
          size: currentMaze.size + 'x' + currentMaze.size,
          time_ms: currentMaze.activeMs,
          moves: currentMaze.moves,
          mean_anchor_latency_ms: meanLatency,
          coach_alerts_shown: currentMaze.coachShown
        });
      }

      function placeCoach(){
        const mazeRect = canvas.getBoundingClientRect();
        const wrapRect = wrap.getBoundingClientRect();
        const leftWithinWrap = mazeRect.left - wrapRect.left + canvas.width + 10;
        coach.style.left = leftWithinWrap + 'px';
        coach.style.top = Math.max(6, (mazeRect.top - wrapRect.top) + 10) + 'px';
      }
      function showCoach(msg){
        coach.textContent = msg + ' Tap to close.';
        placeCoach();
        coach.style.display='block';
        if(currentMaze) currentMaze.coachShown += 1;
        logEvent('coach_shown', {detail: msg});
      }
      function hideCoach(){ coach.style.display='none'; logEvent('coach_closed'); }
      coach.addEventListener('click', hideCoach);
      coach.addEventListener('touchstart', (e)=>{ e.preventDefault(); hideCoach(); }, {passive:false});

      function resizeCanvas(){
        const side = Math.min(520, Math.floor(window.innerWidth * 0.90));
        canvas.width = side; canvas.height = side;
        cellSize = canvas.width / cols;
        placeCoach();
        drawAll();
        if(newMazeBtn.style.display !== 'none'){ positionNewMazeButton(); }
      }
      window.addEventListener('resize', resizeCanvas);

      // ===== Cell / Maze =====
      class Cell{
        constructor(i,j){ this.i=i; this.j=j;
          this.walls={top:true,right:true,bottom:true,left:true};
          this.visited=false; }
        draw(){
          const x = this.i*cellSize, y = this.j*cellSize;
          ctx.strokeStyle = '#2E8B57'; ctx.lineWidth = 2;
          if(this.walls.top){ ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+cellSize,y); ctx.stroke(); }
          if(this.walls.right){ ctx.beginPath(); ctx.moveTo(x+cellSize,y); ctx.lineTo(x+cellSize,y+cellSize); ctx.stroke(); }
          if(this.walls.bottom){ ctx.beginPath(); ctx.moveTo(x+cellSize,y+cellSize); ctx.lineTo(x,y+cellSize); ctx.stroke(); }
          if(this.walls.left){ ctx.beginPath(); ctx.moveTo(x,y+cellSize); ctx.lineTo(x,y); ctx.stroke(); }
        }
        neighborInfos(grid){
          const dirs=[
            {di:0,dj:-1,wall:'top',opp:'bottom'},
            {di:1,dj:0,wall:'right',opp:'left'},
            {di:0,dj:1,wall:'bottom',opp:'top'},
            {di:-1,dj:0,wall:'left',opp:'right'}
          ];
          const out=[];
          for(const d of dirs){
            const ni=this.i+d.di, nj=this.j+d.dj;
            if(ni>=0&&ni<cols&&nj>=0&&nj<rows&&!grid[ni][nj].visited){
              out.push({cell:grid[ni][nj], wall:d.wall, opp:d.opp});
            }
          }
          return out.length? out[Math.floor(Math.random()*out.length)]: undefined;
        }
      }

      function buildGrid(){
        grid = Array.from({length:cols},(_,i)=>Array.from({length:rows},(_,j)=>new Cell(i,j)));
      }
      function generateMaze(){
        buildGrid();
        const stack=[]; let current = grid[0][0];
        current.visited=true;
        while(true){
          const nxt = current.neighborInfos(grid);
          if(nxt){
            const nxtCell = nxt.cell; nxtCell.visited = true;
            current.walls[nxt.wall] = false;
            nxtCell.walls[nxt.opp] = false;
            stack.push(current); current = nxtCell;
          }else if(stack.length){ current = stack.pop(); }
          else break;
        }
        for(let i=0;i<cols;i++) for(let j=0;j<rows;j++) grid[i][j].visited=false;
      }
      function computeDistancesFromGoal(){
        const dist = Array.from({length:cols},()=>Array(rows).fill(Infinity));
        const q=[]; dist[0][0]=0; q.push({i:0,j:0});
        while(q.length){
          const {i,j}=q.shift(); const c=grid[i][j]; const d=dist[i][j];
          const moves=[
            {di:-1,dj:0, cond: !c.walls.left},
            {di:1,dj:0,  cond: !c.walls.right},
            {di:0,dj:-1, cond: !c.walls.top},
            {di:0,dj:1,  cond: !c.walls.bottom}
          ];
          for(const m of moves){
            if(!m.cond) continue;
            const ni=i+m.di, nj=j+m.dj;
            if(ni<0||ni>=cols||nj<0||nj>=rows) continue;
            if(dist[ni][nj] > d+1){ dist[ni][nj]=d+1; q.push({i:ni,j:nj}); }
          }
        }
        return dist;
      }

      // ===== Game control =====
      function resetStateForNewMaze(){
        player = {i:cols-1, j:rows-1};
        tapCount = 0; anchorNeeded = false; wrongProgress = 0;
        lastDist = distMap[player.i][player.j];
        lastAnchorRequiredAt = null;
        coach.style.display='none'; anchorTip.style.display='none';
        mazeCompleted = false;

        mazeIndex += 1;
        currentMaze = { index: mazeIndex, size: cols, activeMs: 0, moves: 0,
                        anchorLatencySum: 0, anchorLatencyCount: 0, coachShown: 0 };
        mazeLiveAccumMs = 0;
        markActivity();
      }
      function newMaze(c){
        cols = rows = c;
        generateMaze();
        distMap = computeDistancesFromGoal();
        resetStateForNewMaze();
        cellSize = canvas.width / cols;
        logEvent('new_maze', {cols, rows});
        drawAll();
      }
      function drawMaze(){
        ctx.clearRect(0,0,canvas.width,canvas.height);
        for(let i=0;i<cols;i++) for(let j=0;j<rows;j++) grid[i][j].draw();
        ctx.fillStyle='rgba(255,209,102,0.35)';
        ctx.fillRect(2, 2, cellSize-4, cellSize-4);
      }
      function positionNewMazeButton(){
        const rect = canvas.getBoundingClientRect();
        const wrapRect = wrap.getBoundingClientRect();
        const centerX = rect.left - wrapRect.left + rect.width/2;
        const centerY = rect.top - wrapRect.top + rect.height/2 + rect.height*0.12;
        newMazeBtn.style.left = `${centerX - newMazeBtn.offsetWidth/2}px`;
        newMazeBtn.style.top = `${centerY}px`;
      }
      function drawAll(){
        drawMaze();
        ctx.fillStyle='rgba(70,130,180,0.65)';
        ctx.fillRect(player.i*cellSize+2, player.j*cellSize+2, cellSize-4, cellSize-4);
        if(player.i===0 && player.j===0){
          ctx.fillStyle='rgba(60,179,113,0.95)';
          ctx.font='bold '+Math.floor(canvas.width*0.06)+'px Arial';
          ctx.textAlign='center';
          ctx.fillText('Completed!', canvas.width/2, canvas.height/2);
          positionNewMazeButton();
          newMazeBtn.style.display = 'block';
        }else{
          newMazeBtn.style.display = 'none';
        }
        statusBar.textContent = `Moves since left-anchor: ${tapCount % ANCHOR_INTERVAL} / ${ANCHOR_INTERVAL}`;
      }
      function requireAnchorIfNeeded(){
        if(anchorNeeded){ anchorTip.style.display='block'; leftAnchorEl.classList.add('flash'); }
        else{ anchorTip.style.display='none'; leftAnchorEl.classList.remove('flash'); }
      }

      // ===== Movement & interactions =====
      function tryMove(dx,dy){
        if(anchorNeeded){ requireAnchorIfNeeded(); return; }
        const cur = grid[player.i][player.j];
        const ni = player.i + dx, nj = player.j + dy;
        if(ni<0||ni>=cols||nj<0||nj>=rows) return;
        if(dx===-1 && cur.walls.left) return;
        if(dx===1 && cur.walls.right) return;
        if(dy===-1 && cur.walls.top) return;
        if(dy===1 && cur.walls.bottom) return;

        const fromI=player.i, fromJ=player.j;
        player.i = ni; player.j = nj;
        tapCount += 1;
        if(currentMaze) currentMaze.moves += 1;
        logEvent('move', {from_i:fromI, from_j:fromJ, to_i:ni, to_j:nj});
        markActivity();

        const newDist = distMap[player.i][player.j];
        if(newDist < lastDist){ wrongProgress = 0; }
        else{
          wrongProgress += 1;
          if(wrongProgress >= WRONG_TURN_THRESHOLD){
            showCoach('You may be moving away from the goal.');
            wrongProgress = 0;
            logEvent('coach_triggered', {i:player.i, j:player.j});
          }
        }
        lastDist = newDist;

        if((tapCount % ANCHOR_INTERVAL) === 0){
          anchorNeeded = true;
          lastAnchorRequiredAt = Date.now();
          requireAnchorIfNeeded();
          logEvent('anchor_required', {i:player.i, j:player.j});
        }

        if(player.i===0 && player.j===0 && !mazeCompleted){
          mazeCompleted = true;
          finalizeCurrentMazeForStats();
          metrics.totalCompletions += 1;
          saveMetrics(metrics);
          refreshMetricUI();
          logEvent('completed', {moves: tapCount, ms: Date.now() - sessionStart});
        }
        drawAll();
      }

      function anchorTapped(){
        let latency = '';
        if(lastAnchorRequiredAt){ latency = Date.now() - lastAnchorRequiredAt; }
        anchorNeeded = false;
        lastAnchorRequiredAt = null;
        requireAnchorIfNeeded();
        leftAnchorEl.classList.add('flash');
        setTimeout(()=>leftAnchorEl.classList.remove('flash'), 800);
        if(currentMaze && latency !== ''){
          currentMaze.anchorLatencySum += latency;
          currentMaze.anchorLatencyCount += 1;
        }
        logEvent('anchor_tap', {i:player.i, j:player.j, tapCount, anchor_latency_ms: latency});
        markActivity();
      }
      leftAnchorEl.addEventListener('click', anchorTapped);
      leftAnchorEl.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' ') { e.preventDefault(); anchorTapped(); }});
      leftAnchorEl.addEventListener('touchstart', (e)=>{ e.preventDefault(); anchorTapped(); }, {passive:false});

      document.getElementById('up').addEventListener('click', ()=>tryMove(0,-1));
      document.getElementById('down').addEventListener('click', ()=>tryMove(0,1));
      document.getElementById('left').addEventListener('click', ()=>tryMove(-1,0));
      document.getElementById('right').addEventListener('click', ()=>tryMove(1,0));
      document.addEventListener('keydown', (e)=>{
        if(e.key==='ArrowUp') tryMove(0,-1);
        if(e.key==='ArrowDown') tryMove(0,1);
        if(e.key==='ArrowLeft') tryMove(-1,0);
        if(e.key==='ArrowRight') tryMove(1,0);
      });

      let sx, sy;
      canvas.addEventListener('touchstart', (e)=>{ const t=e.touches[0]; sx=t.clientX; sy=t.clientY; }, {passive:true});
      canvas.addEventListener('touchend', (e)=>{
        const t=e.changedTouches[0]; const dx=t.clientX-sx; const dy=t.clientY-sy;
        const ax=Math.abs(dx), ay=Math.abs(dy);
        if(ax>ay){ if(dx>0) tryMove(1,0); else tryMove(-1,0); }
        else{ if(dy>0) tryMove(0,1); else tryMove(0,-1); }
      }, {passive:true});

      function applyDifficultyFromSelect(){
        const val = parseInt(difficultySel.value,10);
        newMaze(val);
        logEvent('difficulty_change', {size: val});
        resizeCanvas();
      }
      difficultySel.addEventListener('change', applyDifficultyFromSelect);

      newMazeBtn.addEventListener('click', ()=>{
        newMaze(parseInt(difficultySel.value,10));
        newMazeBtn.style.display = 'none';
      });

      function downloadCSV(){
        try{
          const header = ['maze_index','size','time_ms','number_of_moves','mean_anchor_latency_ms','coach_alerts_shown'];
          const lines = [header.join(',')];
          for(const s of mazeStats){
            lines.push([s.index, s.size, s.time_ms, s.moves, s.mean_anchor_latency_ms, s.coach_alerts_shown].join(','));
          }
          const csvText = '\uFEFF' + lines.join('\r\n');
          const blob = new Blob([csvText], {type:'text/csv;charset=utf-8'});
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'maze_stats.csv';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          setTimeout(()=>URL.revokeObjectURL(url), 0);
        }catch(err){
          console.error('CSV download failed:', err);
          alert('Sorry — couldn’t create the CSV. Check the console for details.');
        }
      }
      downloadBtn.addEventListener('click', downloadCSV);

      // Inject reset button next to download
      const resetBtn = document.createElement('button');
      resetBtn.id = 'resetBtn';
      resetBtn.textContent = 'Reset session data';
      resetBtn.className = 'button';
      if (downloadBtn && downloadBtn.parentNode) {
        if (downloadBtn.nextSibling) {
          downloadBtn.parentNode.insertBefore(resetBtn, downloadBtn.nextSibling);
        } else {
          downloadBtn.parentNode.appendChild(resetBtn);
        }
      } else {
        wrap.appendChild(resetBtn);
      }
      function resetSessionData(){
        const proceed = confirm('This will clear saved totals and completed-maze stats on this device. Continue?');
        if(!proceed) return;
        try {
          localStorage.removeItem(METRIC_KEY);
          metrics = { totalActiveMs: 0, totalCompletions: 0 };
          liveAccumMs = 0; mazeLiveAccumMs = 0; mazeStats.length = 0;
          refreshMetricUI();
          newMaze(parseInt(difficultySel.value,10));
          setActive(false);
          alert('Session reset complete.');
        } catch (e) {
          console.error('Reset failed:', e);
          alert('Sorry — could not reset. See console for details.');
        }
      }
      resetBtn.addEventListener('click', resetSessionData);

      // ===== Init =====
      refreshMetricUI();
      difficultySel.value = '10';
      newMaze(10);
      setActive(false);
      resizeCanvas();
      logEvent('session_start', {init_size: 10});
    })();
    </script>

    <!-- The clinician note card is injected automatically by clinician_feedback.js -->
  </main>
</body>
</html>
