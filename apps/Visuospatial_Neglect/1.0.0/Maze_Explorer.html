<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Maze Explorer Ã¢â‚¬â€ Anchor Latency, Metrics, Idle Timer</title>
  <style>
    :root{
      --green:#2E8B57;
      --dark:#1c6640;
      --anchor:#d62828;
      --goal:#ffd166;
      --player:#4682B4;
      --coach:#ffe8ed;
      --coachBorder:#ef476f;
      --info:#0b7285;
    }
    html, body { margin:0; height:100%; background:#f8f9fa;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      display:flex; flex-direction:column; align-items:center; }
    h2{ margin:12px 8px 4px; color:var(--green); text-align:center;}
    #rules{ margin: 4px 12px 8px; max-width: 740px; background:#ffffff;
      border-left:5px solid var(--green); padding:8px 12px; border-radius:8px;
      font-size:14px; color:#333; }
    #toolbar{ display:flex; gap:12px; align-items:center; justify-content:center;
      margin:6px 0 0; flex-wrap:wrap; }
    #difficulty{ padding:6px 8px; border-radius:8px; border:1px solid #cbd5e1; background:#fff; font-size:14px; }
    .wrap{ position:relative; display:flex; align-items:flex-start; gap:10px; margin-top:8px; }
    #leftAnchor{ width:20px; height:520px; background:var(--anchor); border-radius:4px;
      box-shadow:inset 0 0 0 3px rgba(0,0,0,0.08); touch-action:manipulation; user-select:none; }
    #leftAnchor.flash{ animation: flash 0.5s ease-in-out 3; }
    @keyframes flash { 50%{ filter:brightness(1.4);} }
    #mazeCanvas{ touch-action:none; background:#fff; border:4px solid var(--green); box-shadow:0 0 10px rgba(0,0,0,0.1); }
    #coach{ position:absolute; display:none; z-index:10; background:var(--coach); border:3px solid var(--coachBorder);
      border-radius:12px; padding:14px 16px; width:min(260px, 40vw); box-shadow:0 10px 24px rgba(0,0,0,.25); font-size:16px; line-height:1.3; }
    #coach b{ color:#b30038; }
    #controls{ display:flex; flex-wrap:wrap; justify-content:center; margin:10px 0 12px; max-width:420px; gap:10px; }
    .btn{ width:60px;height:60px;border:0;border-radius:12px; background:var(--green);color:#fff;font-size:24px;
      display:flex;align-items:center;justify-content:center; box-shadow:0 2px 5px rgba(0,0,0,0.2); }
    .btn:active{ background:var(--dark);}
    #anchorTip{ margin-top:6px; color:#a00; font-size:14px; display:none; }
    #statusBar{ margin-top:4px; font-size:13px; color:#333; }
    #logBar{ margin:6px 0 10px; font-size:13px; color:#333; display:flex; gap:10px; align-items:center; }
    #downloadBtn{ border:0; background:#1d72b8; color:#fff; padding:8px 12px; border-radius:10px; box-shadow:0 2px 6px rgba(0,0,0,.2); }
    #metrics{ background:#fff; border-left:5px solid var(--info); padding:8px 12px; border-radius:10px; font-size:14px; color:#0b7285; }
    #idleBadge{ display:none; color:#a00; font-weight:600; }
    @media (max-width: 720px){
      #leftAnchor{ height:70vw; } #mazeCanvas{ width:90vw; height:90vw; } .wrap{ gap:8px; }
      .btn{ width:54px; height:54px; font-size:22px; } #coach{ width:54vw; font-size:15px; }
    }
  </style>
</head>
<body>
  <h2>Maze Explorer Ã¢â‚¬â€ Start <em>bottomÃ¢â‚¬â€˜right</em>, Finish <em>topÃ¢â‚¬â€˜left</em></h2>

  <div id="rules">
    <b>Task:</b> Find your way from the <u>bottomÃ¢â‚¬â€˜right</u> start square to the <u>topÃ¢â‚¬â€˜left</u> yellow goal.<br>
    <b>Rules:</b> Swipe or use arrow buttons to move. Every <b>10 moves</b>, tap the <span style="color:#d62828"><b>red left anchor</b></span> before continuing.
    If the <b>coach panel</b> appears on the right, you may be moving awayÃ¢â‚¬â€<b>tap the panel to close</b> and consider backtracking.<br>
    <b>Timing:</b> The timer counts only <i>active time</i>. If thereÃ¢â‚¬â„¢s no move or anchor tap for <b>30 seconds</b>, timing pauses automatically and resumes on the next action.
  </div>

  <div id="toolbar">
    <label for="difficulty">Difficulty:</label>
    <select id="difficulty" aria-label="Select difficulty">
      <option value="10">Easy (10Ãƒâ€”10)</option>
      <option value="16">Medium (16Ãƒâ€”16)</option>
      <option value="20">Hard (20Ãƒâ€”20)</option>
    </select>
  </div>

  <div class="wrap" id="wrap">
    <div id="leftAnchor" title="Tap here to reÃ¢â‚¬â€˜anchor left"></div>
    <canvas id="mazeCanvas" width="520" height="520"></canvas>
    <div id="coach" role="alert">You might be moving away from the goal on the right. <b>Tap to close</b> and try backtracking.</div>
  </div>
  <div id="anchorTip">Touch the <b>red left anchor</b> to continue.</div>

  <div id="controls">
    <button class="btn" id="up" aria-label="up">&#x2191;</button>
    <button class="btn" id="left" aria-label="left">&#x2190;</button>
    <button class="btn" id="down" aria-label="down">&#x2193;</button>
    <button class="btn" id="right" aria-label="right">&#x2192;</button>
  </div>

  <div id="statusBar"></div>

  <div id="logBar">
    <button id="downloadBtn">Download session log (CSV)</button>
    <span id="idleBadge">Paused Ã¢â‚¬â€ no activity</span>
  </div>

  <div id="metrics">
    Completed mazes: <b><span id="mCompleted">0</span></b> &nbsp;|&nbsp;
    Active time on this device: <b><span id="mActive">00:00:00</span></b>
  </div>

<script>
(function(){
  // ===== Config =====
  const ANCHOR_INTERVAL = 10;
  const WRONG_TURN_THRESHOLD = 5;
  const IDLE_MS = 30000;

  // ===== DOM =====
  const wrap = document.getElementById('wrap');
  const canvas = document.getElementById('mazeCanvas');
  const ctx = canvas.getContext('2d');
  const leftAnchorEl = document.getElementById('leftAnchor');
  const coach = document.getElementById('coach');
  const anchorTip = document.getElementById('anchorTip');
  const statusBar = document.getElementById('statusBar');
  const downloadBtn = document.getElementById('downloadBtn');
  const difficultySel = document.getElementById('difficulty');
  const mCompletedEl = document.getElementById('mCompleted');
  const mActiveEl = document.getElementById('mActive');
  const idleBadge = document.getElementById('idleBadge');

  // Add the "Try a new maze" button (initially hidden), positioned under the "Completed!" text
  let newMazeBtn = document.createElement('button');
  newMazeBtn.id = 'newMazeBtn';
  newMazeBtn.textContent = 'Try a new maze';
  newMazeBtn.style.position = 'absolute';
  newMazeBtn.style.display = 'none';
  newMazeBtn.style.padding = '10px 16px';
  newMazeBtn.style.border = '0';
  newMazeBtn.style.borderRadius = '12px';
  newMazeBtn.style.background = '#1c6640';
  newMazeBtn.style.color = '#fff';
  newMazeBtn.style.boxShadow = '0 4px 10px rgba(0,0,0,0.2)';
  newMazeBtn.style.fontSize = '16px';
  newMazeBtn.style.cursor = 'pointer';
  wrap.style.position = 'relative';
  wrap.appendChild(newMazeBtn);

  // ===== Metrics (localStorage) =====
  const METRIC_KEY = 'maze_metrics_v1';
  function loadMetrics(){
    try { return JSON.parse(localStorage.getItem(METRIC_KEY)) || {totalActiveMs:0, totalCompletions:0}; }
    catch(e){ return {totalActiveMs:0, totalCompletions:0}; }
  }
  function saveMetrics(m){ localStorage.setItem(METRIC_KEY, JSON.stringify(m)); }
  let metrics = loadMetrics();
  function fmtTime(ms){
    let s = Math.floor(ms/1000);
    const h = Math.floor(s/3600); s%=3600;
    const m = Math.floor(s/60); s%=60;
    const pad = n=>String(n).padStart(2,'0');
    return `${pad(h)}:${pad(m)}:${pad(s)}`;
  }
  function refreshMetricUI(){
    mCompletedEl.textContent = metrics.totalCompletions;
    mActiveEl.textContent = fmtTime(metrics.totalActiveMs + liveAccumMs);
  }

  // ===== Game state =====
  let rows=10, cols=10;
  let cellSize = canvas.width / cols;
  let grid=null, distMap=null;
  let player={i:0, j:0};
  let tapCount=0, anchorNeeded=false, wrongProgress=0, lastDist=Infinity;

  // Track anchor latency
  let lastAnchorRequiredAt = null; // timestamp ms when anchor was required

  // ===== Active time tracking with idle pause =====
  let active=false;
  let lastMoveAt = Date.now();
  let lastActiveStart = Date.now();
  let tickTimer = null;
  let liveAccumMs = 0; // session live chunk accumulating between pauses
  let mazeLiveAccumMs = 0; // per-maze live chunk accumulating between pauses

  function setActive(val){
    if(val===active) return;
    active = val;
    if(active){
      lastActiveStart = Date.now();
      idleBadge.style.display='none';
      ensureTicker();
      logEvent('active_resume');
    }else{
      const now = Date.now();
      // Flush session and maze live accumulators
      metrics.totalActiveMs += liveAccumMs;
      liveAccumMs = 0;
      if(currentMaze && !mazeCompleted){
        currentMaze.activeMs += mazeLiveAccumMs;
      }
      mazeLiveAccumMs = 0;
      saveMetrics(metrics);
      refreshMetricUI();
      idleBadge.style.display='inline';
      logEvent('active_pause');
    }
  }

  function ensureTicker(){
    if(tickTimer) return;
    tickTimer = setInterval(()=>{
      if(!active) return;
      const now = Date.now();
      const pauseAt = lastMoveAt + IDLE_MS;
      const end = Math.min(now, pauseAt);

      // Add elapsed since last tick to session + current maze
      const delta = Math.max(0, end - lastActiveStart);
      liveAccumMs += delta;
      if(currentMaze && !mazeCompleted){
        mazeLiveAccumMs += delta;
      }
      lastActiveStart = end;

      refreshMetricUI();
      if(now >= pauseAt){
        setActive(false);
      }
    }, 1000);
  }

  function markActivity(){
    const now = Date.now();
    lastMoveAt = now;
    if(!active) {
      lastActiveStart = now;
      setActive(true);
    }
  }

  document.addEventListener('visibilitychange', ()=>{
    if(document.hidden) setActive(false);
  });

  // ===== Session log (kept minimal) =====
  const sessionStart = Date.now();
  const log = [];
  function logEvent(type, data={}){
    log.push({t: Date.now() - sessionStart, type, ...data});
  }

  // ===== Per-maze stats to export =====
  let mazeStats = []; // array of {index,size,time_ms,moves,mean_anchor_latency_ms,coach_alerts_shown}
  let mazeIndex = 0;
  let currentMaze = null;
  let mazeCompleted = false;

  function finalizeCurrentMazeForStats(){
    if(!currentMaze) return;
    // Flush any in-progress live accumulators up to now (without toggling active state)
    const now = Date.now();
    const pauseAt = lastMoveAt + IDLE_MS;
    const end = Math.min(now, pauseAt);
    const delta = Math.max(0, end - lastActiveStart);
    // Add to session + maze
    liveAccumMs += delta;
    if(!mazeCompleted){
      mazeLiveAccumMs += delta;
    }
    lastActiveStart = end;

    // Commit maze live accum to activeMs
    currentMaze.activeMs += mazeLiveAccumMs;
    mazeLiveAccumMs = 0;

    const meanLatency = currentMaze.anchorLatencyCount > 0
      ? Math.round(currentMaze.anchorLatencySum / currentMaze.anchorLatencyCount)
      : '';

    mazeStats.push({
      index: currentMaze.index,
      size: currentMaze.size + 'x' + currentMaze.size,
      time_ms: currentMaze.activeMs,
      moves: currentMaze.moves,
      mean_anchor_latency_ms: meanLatency,
      coach_alerts_shown: currentMaze.coachShown
    });
  }

  function placeCoach(){
    const mazeRect = canvas.getBoundingClientRect();
    const wrapRect = wrap.getBoundingClientRect();
    const leftWithinWrap = mazeRect.left - wrapRect.left + canvas.width + 10;
    coach.style.left = leftWithinWrap + 'px';
    coach.style.top = Math.max(6, (mazeRect.top - wrapRect.top) + 10) + 'px';
  }
  function showCoach(msg){
    coach.textContent = msg + ' Tap to close.';
    placeCoach();
    coach.style.display='block';
    if(currentMaze) currentMaze.coachShown += 1;
    logEvent('coach_shown', {detail: msg});
  }
  function hideCoach(){
    coach.style.display='none';
    logEvent('coach_closed');
  }
  coach.addEventListener('click', hideCoach);
  coach.addEventListener('touchstart', (e)=>{ e.preventDefault(); hideCoach(); }, {passive:false});

  function resizeCanvas(){
    const side = Math.min(520, window.innerWidth * 0.90);
    canvas.width = side; canvas.height = side;
    cellSize = canvas.width / cols;
    placeCoach();
    drawAll();
    // reposition "Try a new maze" button if visible
    if(newMazeBtn.style.display !== 'none'){
      positionNewMazeButton();
    }
  }
  window.addEventListener('resize', resizeCanvas);

  // ===== Cell / Maze =====
  class Cell{
    constructor(i,j){ this.i=i; this.j=j;
      this.walls={top:true,right:true,bottom:true,left:true};
      this.visited=false; }
    draw(){
      const x = this.i*cellSize, y = this.j*cellSize;
      ctx.strokeStyle = '#2E8B57'; ctx.lineWidth = 2;
      if(this.walls.top){ ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+cellSize,y); ctx.stroke(); }
      if(this.walls.right){ ctx.beginPath(); ctx.moveTo(x+cellSize,y); ctx.lineTo(x+cellSize,y+cellSize); ctx.stroke(); }
      if(this.walls.bottom){ ctx.beginPath(); ctx.moveTo(x+cellSize,y+cellSize); ctx.lineTo(x,y+cellSize); ctx.stroke(); }
      if(this.walls.left){ ctx.beginPath(); ctx.moveTo(x,y+cellSize); ctx.lineTo(x,y); ctx.stroke(); }
    }
    neighborInfos(grid){
      const dirs=[
        {di:0,dj:-1,wall:'top',opp:'bottom'},
        {di:1,dj:0,wall:'right',opp:'left'},
        {di:0,dj:1,wall:'bottom',opp:'top'},
        {di:-1,dj:0,wall:'left',opp:'right'}
      ];
      const out=[];
      for(const d of dirs){
        const ni=this.i+d.di, nj=this.j+d.dj;
        if(ni>=0&&ni<cols&&nj>=0&&nj<rows&&!grid[ni][nj].visited){
          out.push({cell:grid[ni][nj], wall:d.wall, opp:d.opp});
        }
      }
      return out.length? out[Math.floor(Math.random()*out.length)]: undefined;
    }
  }

  function buildGrid(){
    grid = Array.from({length:cols},(_,i)=>Array.from({length:rows},(_,j)=>new Cell(i,j)));
  }

  function generateMaze(){
    buildGrid();
    const stack=[]; let current = grid[0][0];
    current.visited=true;
    while(true){
      const nxt = current.neighborInfos(grid);
      if(nxt){
        const nxtCell = nxt.cell; nxtCell.visited = true;
        current.walls[nxt.wall] = false;
        nxtCell.walls[nxt.opp] = false;
        stack.push(current); current = nxtCell;
      }else if(stack.length){ current = stack.pop(); }
      else break;
    }
    for(let i=0;i<cols;i++) for(let j=0;j<rows;j++) grid[i][j].visited=false;
  }

  function computeDistancesFromGoal(){
    const dist = Array.from({length:cols},()=>Array(rows).fill(Infinity));
    const q=[]; dist[0][0]=0; q.push({i:0,j:0});
    while(q.length){
      const {i,j}=q.shift(); const c=grid[i][j]; const d=dist[i][j];
      const moves=[
        {di:-1,dj:0, cond: !c.walls.left},
        {di:1,dj:0,  cond: !c.walls.right},
        {di:0,dj:-1, cond: !c.walls.top},
        {di:0,dj:1,  cond: !c.walls.bottom}
      ];
      for(const m of moves){
        if(!m.cond) continue;
        const ni=i+m.di, nj=j+m.dj;
        if(ni<0||ni>=cols||nj<0||nj>=rows) continue;
        if(dist[ni][nj] > d+1){ dist[ni][nj]=d+1; q.push({i:ni,j:nj}); }
      }
    }
    return dist;
  }

  // ===== Game control =====
  function resetStateForNewMaze(){
    player = {i:cols-1, j:rows-1};
    tapCount = 0; anchorNeeded = false; wrongProgress = 0;
    lastDist = distMap[player.i][player.j];
    lastAnchorRequiredAt = null;
    coach.style.display='none'; anchorTip.style.display='none';
    mazeCompleted = false;

    // Start per-maze stats
    mazeIndex += 1;
    currentMaze = {
      index: mazeIndex,
      size: cols,
      activeMs: 0,
      moves: 0,
      anchorLatencySum: 0,
      anchorLatencyCount: 0,
      coachShown: 0
    };
    mazeLiveAccumMs = 0;
    markActivity();
  }

  function newMaze(c){
    cols = rows = c;
    generateMaze();
    distMap = computeDistancesFromGoal();
    resetStateForNewMaze();
    cellSize = canvas.width / cols;
    logEvent('new_maze', {cols, rows});
    drawAll();
  }

  function drawMaze(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    for(let i=0;i<cols;i++) for(let j=0;j<rows;j++) grid[i][j].draw();
    ctx.fillStyle='rgba(255,209,102,0.35)';
    ctx.fillRect(2, 2, cellSize-4, cellSize-4);
  }

  function positionNewMazeButton(){
    const rect = canvas.getBoundingClientRect();
    const wrapRect = wrap.getBoundingClientRect();
    // place roughly below center text
    const centerX = rect.left - wrapRect.left + rect.width/2;
    const centerY = rect.top - wrapRect.top + rect.height/2 + rect.height*0.12;
    newMazeBtn.style.left = `${centerX}px`;
    newMazeBtn.style.top = `${centerY}px`;
  }

  function drawAll(){
    drawMaze();
    ctx.fillStyle='rgba(70,130,180,0.65)';
    ctx.fillRect(player.i*cellSize+2, player.j*cellSize+2, cellSize-4, cellSize-4);
    if(player.i===0 && player.j===0){
      ctx.fillStyle='rgba(60,179,113,0.95)';
      ctx.font='bold '+Math.floor(canvas.width*0.06)+'px Arial';
      ctx.textAlign='center';
      ctx.fillText('Completed!', canvas.width/2, canvas.height/2);
      // Show "Try a new maze" button
      positionNewMazeButton();
      newMazeBtn.style.display = 'block';
    }else{
      newMazeBtn.style.display = 'none';
    }
    statusBar.textContent = `Moves since left-anchor: ${tapCount % ANCHOR_INTERVAL} / ${ANCHOR_INTERVAL}`;
  }

  function requireAnchorIfNeeded(){
    if(anchorNeeded){ anchorTip.style.display='block'; leftAnchorEl.classList.add('flash'); }
    else{ anchorTip.style.display='none'; leftAnchorEl.classList.remove('flash'); }
  }

  // ===== Movement & interactions =====
  function tryMove(dx,dy){
    if(anchorNeeded){ requireAnchorIfNeeded(); return; }
    const cur = grid[player.i][player.j];
    const ni = player.i + dx, nj = player.j + dy;
    if(ni<0||ni>=cols||nj<0||nj>=rows) return;
    if(dx===-1 && cur.walls.left) return;
    if(dx===1 && cur.walls.right) return;
    if(dy===-1 && cur.walls.top) return;
    if(dy===1 && cur.walls.bottom) return;

    const fromI=player.i, fromJ=player.j;
    player.i = ni; player.j = nj;
    tapCount += 1;
    if(currentMaze) currentMaze.moves += 1;
    logEvent('move', {from_i:fromI, from_j:fromJ, to_i:ni, to_j:nj});
    markActivity();

    const newDist = distMap[player.i][player.j];
    if(newDist < lastDist){ wrongProgress = 0; }
    else{
      wrongProgress += 1;
      if(wrongProgress >= WRONG_TURN_THRESHOLD){
        showCoach('You may be moving away from the goal.');
        wrongProgress = 0;
        logEvent('coach_triggered', {i:player.i, j:player.j});
      }
    }
    lastDist = newDist;

    if((tapCount % ANCHOR_INTERVAL) === 0){
      anchorNeeded = true;
      lastAnchorRequiredAt = Date.now(); // start latency clock
      requireAnchorIfNeeded();
      logEvent('anchor_required', {i:player.i, j:player.j});
    }

    if(player.i===0 && player.j===0 && !mazeCompleted){
      // Finalize stats
      mazeCompleted = true;
      finalizeCurrentMazeForStats();

      metrics.totalCompletions += 1;
      saveMetrics(metrics);
      refreshMetricUI();
      logEvent('completed', {moves: tapCount, ms: Date.now() - sessionStart});
    }
    drawAll();
  }

  function anchorTapped(){
    // compute compliance latency if we were waiting
    let latency = '';
    if(lastAnchorRequiredAt){
      latency = Date.now() - lastAnchorRequiredAt;
    }
    anchorNeeded = false;
    lastAnchorRequiredAt = null;
    requireAnchorIfNeeded();
    leftAnchorEl.classList.add('flash');
    setTimeout(()=>leftAnchorEl.classList.remove('flash'), 800);
    if(currentMaze && latency !== ''){
      currentMaze.anchorLatencySum += latency;
      currentMaze.anchorLatencyCount += 1;
    }
    logEvent('anchor_tap', {i:player.i, j:player.j, tapCount, anchor_latency_ms: latency});
    markActivity();
  }
  leftAnchorEl.addEventListener('click', anchorTapped);
  leftAnchorEl.addEventListener('touchstart', (e)=>{ e.preventDefault(); anchorTapped(); }, {passive:false});

  // buttons/keys/swipes
  document.getElementById('up').addEventListener('click', ()=>tryMove(0,-1));
  document.getElementById('down').addEventListener('click', ()=>tryMove(0,1));
  document.getElementById('left').addEventListener('click', ()=>tryMove(-1,0));
  document.getElementById('right').addEventListener('click', ()=>tryMove(1,0));
  document.addEventListener('keydown', (e)=>{
    if(e.key==='ArrowUp') tryMove(0,-1);
    if(e.key==='ArrowDown') tryMove(0,1);
    if(e.key==='ArrowLeft') tryMove(-1,0);
    if(e.key==='ArrowRight') tryMove(1,0);
  });
  let sx, sy;
  canvas.addEventListener('touchstart', (e)=>{ const t=e.touches[0]; sx=t.clientX; sy=t.clientY; }, {passive:true});
  canvas.addEventListener('touchend', (e)=>{
    const t=e.changedTouches[0]; const dx=t.clientX-sx; const dy=t.clientY-sy;
    const ax=Math.abs(dx), ay=Math.abs(dy);
    if(ax>ay){ if(dx>0) tryMove(1,0); else tryMove(-1,0); }
    else{ if(dy>0) tryMove(0,1); else tryMove(0,-1); }
  }, {passive:true});

  // difficulty select
  function applyDifficultyFromSelect(){
    const val = parseInt(difficultySel.value,10);
    newMaze(val);
    logEvent('difficulty_change', {size: val});
    resizeCanvas();
  }
  difficultySel.addEventListener('change', applyDifficultyFromSelect);

  // Handle "Try a new maze" click Ã¢â‚¬â€ keep current difficulty
  newMazeBtn.addEventListener('click', ()=>{
    newMaze(parseInt(difficultySel.value,10));
    newMazeBtn.style.display = 'none';
  });

  // ===== Download per-maze CSV =====
  function downloadCSV(){
    try{
      // If the current maze is completed, stats are already finalized.
      // If not completed yet, we don't include it in the CSV (only completed mazes).
      const header = ['maze_index','size','time_ms','number_of_moves','mean_anchor_latency_ms','coach_alerts_shown'];
      const lines = [header.join(',')];

      for(const s of mazeStats){
        const row = [
          s.index,
          s.size,
          s.time_ms,
          s.moves,
          s.mean_anchor_latency_ms,
          s.coach_alerts_shown
        ].join(',');
        lines.push(row);
      }

      const csvText = '\uFEFF' + lines.join('\r\n');
      const blob = new Blob([csvText], {type:'text/csv;charset=utf-8'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'maze_stats.csv';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      setTimeout(()=>URL.revokeObjectURL(url), 0);
      console.log(`[Maze] Downloaded stats CSV with ${Math.max(0, lines.length-1)} rows.`);
    }catch(err){
      console.error('CSV download failed:', err);
      alert('Sorry Ã¢â‚¬â€ couldnÃ¢â‚¬â„¢t create the CSV. Check the console for details.');
    }
  }

  downloadBtn.textContent = 'Download stats (CSV)';
  downloadBtn.removeEventListener?.('click', downloadCSV); // precaution
  downloadBtn.addEventListener('click', downloadCSV);
  // ===== Reset session data (clear localStorage + in-memory stats) =====
  const resetBtn = document.createElement('button');
  resetBtn.id = 'resetBtn';
  resetBtn.textContent = 'Reset session data';
  resetBtn.style.marginLeft = '8px';
  resetBtn.style.padding = '8px 12px';
  resetBtn.style.border = '0';
  resetBtn.style.borderRadius = '10px';
  resetBtn.style.background = '#b23b3b';
  resetBtn.style.color = '#fff';
  resetBtn.style.cursor = 'pointer';
  resetBtn.title = 'Clear saved totals and completed-maze stats';

  // Insert next to the download button if possible
  if (downloadBtn && downloadBtn.parentNode) {
    if (downloadBtn.nextSibling) {
      downloadBtn.parentNode.insertBefore(resetBtn, downloadBtn.nextSibling);
    } else {
      downloadBtn.parentNode.appendChild(resetBtn);
    }
  } else {
    // Fallback: append to wrapper
    wrap.appendChild(resetBtn);
  }

  function resetSessionData(){
    const proceed = confirm('This will clear saved totals and completed-maze stats on this device. Continue?');
    if(!proceed) return;

    try {
      // Clear persisted totals
      localStorage.removeItem(METRIC_KEY);

      // Reset in-memory aggregates
      metrics = { totalActiveMs: 0, totalCompletions: 0 };
      liveAccumMs = 0;
      mazeLiveAccumMs = 0;

      // Clear completed maze stats (CSV rows)
      mazeStats.length = 0;

      // Refresh UI and start a fresh maze at the current difficulty
      refreshMetricUI();
      newMaze(parseInt(difficultySel.value,10));
      setActive(false);
      alert('Session reset complete.');
    } catch (e) {
      console.error('Reset failed:', e);
      alert('Sorry Ã¢â‚¬â€ could not reset. See console for details.');
    }
  }

  resetBtn.addEventListener('click', resetSessionData);


  // ===== Init =====
  refreshMetricUI();
  difficultySel.value = '10';
  newMaze(10);
  setActive(false);
  resizeCanvas();
  logEvent('session_start', {init_size: 10});
})();</script>
</body>
</html>
