<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Word Scavenge Ã¢â‚¬â€ USN rehab (updated)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @keyframes wiggle { 0%{transform:translateX(0)} 25%{transform:translateX(-4px)} 75%{transform:translateX(4px)} 100%{transform:translateX(0)} }
    .wiggle { animation: wiggle .22s ease-in-out; }
    .anchor-stripe { width: 44px; background: #ef4444; cursor: pointer; display: flex; align-items: center; justify-content: center; color: white; font-weight: 700; writing-mode: vertical-rl; text-orientation: mixed; user-select: none; }
    .anchor-stripe.sticky { position: sticky; top: 7rem; border-radius: 10px; box-shadow: 0 10px 20px rgba(0,0,0,.15); }
  </style>
</head>
<body class="min-h-screen bg-slate-50 text-slate-900">
  <header class="sticky top-0 z-10 bg-white/80 backdrop-blur border-b border-slate-200">
    <div class="max-w-6xl mx-auto px-4 py-3 flex items-center justify-between gap-3">
      <div class="flex items-center gap-3">
        <div class="w-10 h-10 rounded-2xl bg-slate-900 text-white grid place-content-center font-bold">WS</div>
        <div>
          <div class="text-xl font-semibold">Word Scavenge</div>
          <div class="text-xs text-slate-500">Tap the <span class="text-red-600 font-semibold">left red anchor stripe</span>, then pick a left word Ã¢â€ â€™ match on the right</div>
        </div>
      </div>
      <div class="flex items-center gap-2">
        <button id="helpBtn" class="px-3 py-2 rounded-xl border border-slate-300 hover:bg-slate-100 text-sm">Hide help</button>
        <button id="settingsBtn" class="px-3 py-2 rounded-xl border border-slate-300 hover:bg-slate-100 text-sm">Hide settings</button>
        <button id="pauseBtn" class="px-3 py-2 rounded-xl text-sm shadow bg-amber-600 text-white">Pause</button>
        <button id="newBtn" class="px-3 py-2 rounded-xl text-sm bg-slate-900 text-white shadow">New session</button>
      </div>
    </div>
  </header>

  <main class="max-w-6xl mx-auto px-4 mt-4">
    <section id="help" class="mb-4 p-4 rounded-2xl bg-white border border-slate-200 shadow-sm">
      <div class="font-semibold mb-1">How it works</div>
      <ul class="list-disc ml-5 text-sm text-slate-600 space-y-1">
        <li>Before <em>every</em> match, the patient must <span class="font-semibold text-red-600">tap the red left anchor stripe</span>.</li>
        <li>Then select a word on the <span class="font-semibold">left</span>, and match it with the corresponding word on the right.</li>
        <li>Correct matches are <span class="font-semibold">locked and highlighted in green on both sides</span>.</li>
        <li>Starting on the right is blocked and logged as a compliance event.</li>
        <li>Timer pauses automatically after <span class="font-mono" id="idleHint">30s</span> of inactivity.</li>
        <li>Download a CSV log with all sessions stored locally (persists between runs).</li>
      </ul>
    </section>

    <section id="settings" class="mb-6 p-4 rounded-2xl bg-white border border-slate-200 shadow-sm grid md:grid-cols-2 gap-4">
      <div class="space-y-3">
        <label class="block text-sm">Word set</label>
        <select id="setSelect" class="w-full p-2 rounded-xl border border-slate-300"></select>

        <label class="block text-sm">Number of pairs: <span id="pairCountLab">8</span></label>
        <input type="range" id="pairCount" min="4" max="12" value="8" class="w-full" />

        <div class="flex items-center gap-2">
          <input id="requireLeftStart" type="checkbox" checked />
          <label for="requireLeftStart" class="text-sm">Require left-start (recommended)</label>
        </div>

        <div class="flex items-center gap-2">
          <input id="requireAnchor" type="checkbox" checked />
          <label for="requireAnchor" class="text-sm">Require left-margin anchor before each match</label>
        </div>

        <label class="block text-sm">Auto-pause if idle (seconds)</label>
        <input type="number" id="idleSecs" min="5" max="300" value="30" class="w-28 p-2 rounded-xl border border-slate-300" />

        <div class="flex items-center gap-2">
          <input id="bigText" type="checkbox" checked />
          <label for="bigText" class="text-sm">Large text mode</label>
        </div>

        <div class="flex gap-2">
          <button id="downloadBtn" class="px-3 py-2 rounded-xl bg-slate-900 text-white text-sm shadow">Download CSV log</button>
          <button id="clearBtn" class="px-3 py-2 rounded-xl bg-white text-slate-700 border border-slate-300 text-sm hover:bg-slate-50">Clear all data</button>
        </div>
      </div>

      <div class="space-y-3">
        <div class="flex items-center gap-2">
          <input id="useCustom" type="checkbox" />
          <label for="useCustom" class="text-sm">Use custom list</label>
        </div>
        <textarea id="customPairs" disabled class="w-full h-40 p-3 rounded-xl border border-slate-300 disabled:opacity-50 font-mono text-xs" placeholder="left,right\ncat,meow\n..."></textarea>
        <div class="text-xs text-slate-500">Format: one pair per line, comma-separated. Left word will appear in the left column.</div>
      </div>
    </section>

    <!-- Stats cards -->
    <section class="grid md:grid-cols-5 gap-3 mb-4">
      <div class="rounded-2xl bg-white border border-slate-200 shadow-sm p-3"><div class="text-xs text-slate-500">Solved</div><div id="statSolved" class="text-xl font-semibold">0/0</div></div>
      <div class="rounded-2xl bg-white border border-slate-200 shadow-sm p-3"><div class="text-xs text-slate-500">Accuracy</div><div id="statAcc" class="text-xl font-semibold">0%</div></div>
      <div class="rounded-2xl bg-white border border-slate-200 shadow-sm p-3"><div class="text-xs text-slate-500">Errors</div><div id="statErr" class="text-xl font-semibold">0</div></div>
      <div class="rounded-2xl bg-white border border-slate-200 shadow-sm p-3"><div class="text-xs text-slate-500">Right-first attempts</div><div id="statRFA" class="text-xl font-semibold">0</div></div>
      <div class="rounded-2xl bg-white border border-slate-200 shadow-sm p-3"><div class="text-xs text-slate-500">Active time</div><div id="statTime" class="text-xl font-semibold">0:00</div></div>
    </section>

    <!-- Game area -->
    <section class="grid md:grid-cols-[auto,1fr,1fr] items-start gap-4">
      <!-- Left anchor stripe -->
      <div class="anchor-stripe sticky" id="anchorBtn">ANCHOR</div>

      <!-- Left column -->
      <div class="p-4 rounded-2xl bg-white border border-slate-200 shadow-sm">
        <div class="text-sm font-semibold mb-2">Left Ã¢â‚¬â€ start here</div>
        <div id="leftList" class="grid gap-2"></div>
      </div>

      <!-- Right column -->
      <div class="p-4 rounded-2xl bg-white border border-slate-200 shadow-sm">
        <div class="text-sm font-semibold mb-2">Right Ã¢â‚¬â€ find the match</div>
        <div id="rightList" class="grid gap-2"></div>
      </div>
    </section>

    <section id="completeBanner" class="hidden mt-6 p-4 rounded-2xl bg-emerald-50 border border-emerald-200 text-emerald-900">
      <div class="font-semibold">Session complete</div>
      <div class="text-sm">Well done! Download the CSV log for your records, or start a new session.</div>
    </section>
  </main>

  <!-- Pause overlay -->
  <div id="pauseOverlay" class="hidden fixed inset-0 bg-black/40 grid place-items-center">
    <div class="bg-white p-6 rounded-2xl shadow-2xl w-[min(92vw,560px)] text-center">
      <div class="text-xl font-semibold mb-1">Paused</div>
      <div class="text-sm text-slate-600 mb-4">Timer is stopped. Click resume to continue.</div>
      <button id="resumeBtn" class="px-4 py-2 rounded-xl bg-emerald-600 text-white shadow">Resume</button>
    </div>
  </div>

  <script>
  // -------- Word sets --------
  const SETS = {
    "Everyday pairs": [
      ["dog","bark"],["rain","umbrella"],["key","lock"],["table","chair"],["tooth","brush"],["shoe","lace"],["phone","call"],["cake","birthday"],["door","handle"],["pen","write"],["light","switch"],["plant","water"],
    ],
    Opposites: [
      ["hot","cold"],["up","down"],["day","night"],["open","closed"],["fast","slow"],["early","late"],["loud","quiet"],["full","empty"],["hard","soft"],["bright","dim"],
    ],
    Synonyms: [
      ["happy","glad"],["quick","fast"],["angry","mad"],["small","little"],["smart","clever"],["large","big"],["silent","quiet"],["ill","sick"],["start","begin"],["finish","end"],
    ],
    "Kitchen & home": [
      ["knife","cut"],["pan","fry"],["broom","sweep"],["toaster","bread"],["kettle","boil"],["plate","dish"],["cup","tea"],["bin","rubbish"],["sink","wash"],["bed","sleep"],
    ],
    Games: [
      ["chess","board"],["tennis","racket"],["football","goal"],["basketball","hoop"],["golf","club"],["baseball","bat"],["poker","cards"],["bowling","pins"],["video game","controller"],["hide-and-seek","count"],
    ],
    Jobs: [
      ["doctor","hospital"],["teacher","classroom"],["chef","kitchen"],["pilot","airplane"],["farmer","field"],["nurse","patient"],["engineer","design"],["artist","paint"],["lawyer","court"],["firefighter","hose"],
    ],
  };

  // -------- Persistence --------
  const PERSIST_KEY = 'ws_persist_v1';
  function loadPersist(){ try{ const j = localStorage.getItem(PERSIST_KEY); return j ? JSON.parse(j) : {sessions: []}; }catch{ return {sessions: []}; } }
  function savePersist(obj){ try{ localStorage.setItem(PERSIST_KEY, JSON.stringify(obj)); }catch{} }
  function clearPersist(){ try{ localStorage.removeItem(PERSIST_KEY); }catch{} }

  // -------- State --------
  let requireLeftStart = true;
  let requireAnchor = true;
  let idleSecs = 30;
  let bigText = true;
  let useCustom = false;
  let customPairsText = "left,right\ndog,bark\nkey,lock\nrain,umbrella\nshoe,lace\nphone,call\nlight,switch\nplant,water";
  let setName = "Everyday pairs";
  let pairCount = 8;

  let leftWords = [];
  let rightWords = [];
  let pairMap = {};
  let solvedLefts = new Set();
  let solvedRights = new Set();

  let selectedLeft = null;
  let rightFirstAttempts = 0;
  let errors = 0;

  let paused = false;
  let sessionStart = Date.now();
  let totalPaused = 0; // ms
  let pauseStart = null;
  let displayTimerId = null;
  let idleTimerId = null;
  let idlePauses = 0;

  // anchor + trial timing
  let anchorTapped = false;
  let anchorAtMs = 0;
  let currentTrial = null; // {left, leftAtMs, errors, anchorAtMs}
  let anchorReminders = 0;

  const logs = [];
  let persist = loadPersist();
  let currentSessionIdx = -1;
  let sessionUUID = null;

  // -------- Utils --------
  function shuffle(arr, seed=Math.floor(Math.random()*1e9)){
    const a = arr.slice();
    let s = seed;
    for(let i=a.length-1; i>0; i--){
      s = (s * 1664525 + 1013904223) % 4294967296;
      const r = s / 4294967296;
      const j = Math.floor(r * (i+1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }
  function beep(freq=520, duration=120){
    try{
      const ctx = new (window.AudioContext||window.webkitAudioContext)();
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = 'sine'; o.frequency.value=freq; o.connect(g); g.connect(ctx.destination);
      o.start(); g.gain.setValueAtTime(0.2, ctx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + duration/1000);
      setTimeout(()=>ctx.close(), duration+50);
    }catch{}
  }
  function msFmt(ms){ const s=Math.floor(ms/1000), m=Math.floor(s/60), ss=s%60; return `${m}:${String(ss).padStart(2,'0')}`; }
  function avg(a){ return a.length ? a.reduce((s,x)=>s+x,0)/a.length : 0; }
  function median(a){ if(!a.length) return 0; const b=[...a].sort((x,y)=>x-y); const mid=Math.floor(b.length/2); return b.length%2?b[mid]:(b[mid-1]+b[mid])/2; }
  function debounce(fn, ms=120){ let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), ms); }; }

  // -------- DOM refs --------
  const setSelect = document.getElementById('setSelect');
  const pairCountLab = document.getElementById('pairCountLab');
  const pairCountInp = document.getElementById('pairCount');
  const requireLeftStartInp = document.getElementById('requireLeftStart');
  const requireAnchorInp = document.getElementById('requireAnchor');
  const idleSecsInp = document.getElementById('idleSecs');
  const bigTextInp = document.getElementById('bigText');
  const useCustomInp = document.getElementById('useCustom');
  const customPairsTA = document.getElementById('customPairs');
  const downloadBtn = document.getElementById('downloadBtn');
  const clearBtn = document.getElementById('clearBtn');
  const idleHint = document.getElementById('idleHint');

  const leftList = document.getElementById('leftList');
  const rightList = document.getElementById('rightList');
  const statSolved = document.getElementById('statSolved');
  const statAcc = document.getElementById('statAcc');
  const statErr = document.getElementById('statErr');
  const statRFA = document.getElementById('statRFA');
  const statTime = document.getElementById('statTime');
  const completeBanner = document.getElementById('completeBanner');

  const anchorBtn = document.getElementById('anchorBtn');

  const help = document.getElementById('help');
  const helpBtn = document.getElementById('helpBtn');
  const settings = document.getElementById('settings');
  const settingsBtn = document.getElementById('settingsBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const newBtn = document.getElementById('newBtn');
  const pauseOverlay = document.getElementById('pauseOverlay');
  const resumeBtn = document.getElementById('resumeBtn');

  // -------- Init controls --------
  function initControls(){
    // set list
    setSelect.innerHTML = Object.keys(SETS).map(k=>`<option>${k}</option>`).join('');
    setSelect.value = setName;
    pairCountInp.max = String(Math.max(4, SETS[setName].length));

    setSelect.addEventListener('change', ()=>{ setName = setSelect.value; pairCountInp.max = String(Math.max(4, SETS[setName].length)); if(pairCount>SETS[setName].length){ pairCount=SETS[setName].length; pairCountInp.value=pairCount; } newSession(); });
    pairCountInp.addEventListener('input', ()=>{ pairCount = parseInt(pairCountInp.value); pairCountLab.textContent = pairCount; newSession(); });

    requireLeftStartInp.addEventListener('change', ()=>{ requireLeftStart = requireLeftStartInp.checked; });
    requireAnchorInp.addEventListener('change', ()=>{ requireAnchor = requireAnchorInp.checked; });
    idleSecsInp.addEventListener('change', ()=>{ idleSecs = Math.max(5, Math.min(300, Number(idleSecsInp.value))); idleHint.textContent = idleSecs + 's'; resetIdle(); });
    bigTextInp.addEventListener('change', ()=>{ bigText = bigTextInp.checked; renderLists(); adjustAnchorHeight(); });

    useCustomInp.addEventListener('change', ()=>{ useCustom = useCustomInp.checked; customPairsTA.disabled = !useCustom; newSession(); });
    customPairsTA.addEventListener('input', ()=>{ customPairsText = customPairsTA.value; newSession(); });

    downloadBtn.addEventListener('click', downloadCSV);
    clearBtn.addEventListener('click', ()=>{ clearPersist(); persist = loadPersist(); currentSessionIdx = -1; newSession(); alert('All stored sessions cleared.'); });

    helpBtn.addEventListener('click', ()=>{ const hidden = help.classList.toggle('hidden'); helpBtn.textContent = hidden ? 'Show help' : 'Hide help'; });
    settingsBtn.addEventListener('click', ()=>{ const hidden = settings.classList.toggle('hidden'); settingsBtn.textContent = hidden ? 'Show settings' : 'Hide settings'; });

    pauseBtn.addEventListener('click', ()=>{ if(paused) resume(); else pause(); });
    newBtn.addEventListener('click', newSession);
    resumeBtn.addEventListener('click', ()=>{ resume(); resetIdle(); });

    window.addEventListener('pointerdown', resetIdle);
    window.addEventListener('keydown', resetIdle);
    window.addEventListener('resize', debounce(()=>adjustAnchorHeight(), 150));
  }

  // -------- Persistence helpers for sessions --------
  function finalizePersistSession(){
    if(currentSessionIdx < 0) return;
    const now = Date.now();
    const rec = persist.sessions[currentSessionIdx];
    rec.ended_at = now;
    rec.total_time_ms = now - sessionStart;
    rec.active_time_ms = now - sessionStart - totalPaused;
    rec.errors = errors;
    rec.right_first_attempts = rightFirstAttempts;
    rec.idle_pauses = idlePauses;
    rec.anchor_reminders = anchorReminders;
    rec.setName = setName; rec.pairCount = pairCount;
    savePersist(persist);
  }
  function beginPersistSession(){
    persist = loadPersist();
    const now = Date.now();
    sessionUUID = (window.crypto && crypto.randomUUID) ? crypto.randomUUID() : ('s_'+ now);
    const rec = { id: sessionUUID, started_at: now, setName, pairCount, trials: [], errors: 0, right_first_attempts: 0, idle_pauses: 0, anchor_reminders: 0, total_time_ms: 0, active_time_ms: 0 };
    persist.sessions.push(rec);
    currentSessionIdx = persist.sessions.length - 1;
    savePersist(persist);
  }

  // -------- Session lifecycle --------
  function newSession(){
    // close previous persisted session, then start a new one
    finalizePersistSession();

    sessionStart = Date.now();
    totalPaused = 0; pauseStart = null; updateTime(true);
    idlePauses = 0; solvedLefts = new Set(); solvedRights = new Set();
    selectedLeft = null; errors = 0; rightFirstAttempts = 0; anchorReminders = 0;
    logs.length = 0;
    paused = false; pauseOverlay.classList.add('hidden'); pauseBtn.textContent = 'Pause'; pauseBtn.className = 'px-3 py-2 rounded-xl text-sm shadow bg-amber-600 text-white';
    anchorTapped = false; anchorAtMs = 0; currentTrial = null;

    // build pairs
    const raw = useCustom ? customPairsText.split(/\n|\r/).map(l=>l.trim()).filter(Boolean).map(l=>l.split(',').map(s=>s.trim())).filter(a=>a.length===2) : SETS[setName];
    const clipped = raw.slice(0, Math.min(pairCount, raw.length));
    const left = shuffle(clipped.map(p=>p[0]));
    const right = shuffle(clipped.map(p=>p[1]));
    const map = {}; clipped.forEach(([l,r])=> map[l]=r);

    leftWords = left; rightWords = right; pairMap = map;

    renderLists(); updateStats(); completeBanner.classList.add('hidden');
    beginPersistSession();
    resetIdle();
    setTimeout(adjustAnchorHeight, 0);
  }

  function pause(){ if(paused) return; paused = true; pauseStart = Date.now(); pauseOverlay.classList.remove('hidden'); pauseBtn.textContent = 'Resume'; pauseBtn.className = 'px-3 py-2 rounded-xl text-sm shadow bg-emerald-600 text-white'; }
  function resume(){ if(!paused) return; paused = false; const dur = Date.now()-pauseStart; totalPaused += dur; pauseStart=null; pauseOverlay.classList.add('hidden'); pauseBtn.textContent = 'Pause'; pauseBtn.className = 'px-3 py-2 rounded-xl text-sm shadow bg-amber-600 text-white'; savePersist(persist); }

  function updateTime(reset){
    if(reset && displayTimerId){ clearInterval(displayTimerId); displayTimerId=null; }
    const tick = ()=>{ if(!paused){ const now = Date.now(); const base = now - sessionStart - totalPaused; statTime.textContent = msFmt(base); } };
    displayTimerId = setInterval(tick, 250);
  }

  function resetIdle(){
    if(idleTimerId) clearTimeout(idleTimerId);
    idleTimerId = setTimeout(()=>{ if(!paused){ pause(); idlePauses++; if(currentSessionIdx>=0){ persist.sessions[currentSessionIdx].idle_pauses = idlePauses; savePersist(persist); } } }, idleSecs*1000);
  }

  // -------- Render --------
  function makeWordBtn(text, side){
    const btn = document.createElement('button');
    btn.textContent = text;
    btn.className = [
      'text-left px-4 py-3 rounded-2xl border shadow-sm transition-transform',
      bigText? 'text-xl':'text-base',
      'bg-white hover:bg-slate-50 border-slate-300'
    ].join(' ');
    btn.dataset.word = text;
    btn.dataset.side = side;
    return btn;
  }

  function renderLists(){
    leftList.innerHTML = ''; rightList.innerHTML = '';
    leftWords.forEach(w=>{
      const btn = makeWordBtn(w,'left');
      if(solvedLefts.has(w)) makeGreen(btn);
      btn.addEventListener('click', ()=>onLeftClick(w, btn));
      leftList.appendChild(btn);
    });
    rightWords.forEach(w=>{
      const btn = makeWordBtn(w,'right');
      if(solvedRights.has(w)) makeGreen(btn);
      btn.addEventListener('click', ()=>onRightClick(w, btn));
      rightList.appendChild(btn);
    });
  }

  function makeGreen(el){
    el.classList.remove('bg-white','hover:bg-slate-50','border-slate-300');
    el.classList.add('bg-emerald-500','text-white','border-emerald-600');
    el.disabled = true;
  }

  function highlightPair(left, right){
    [...leftList.children].forEach(el=>{ if(el.dataset.word===left){ makeGreen(el); }});
    [...rightList.children].forEach(el=>{ if(el.dataset.word===right){ makeGreen(el); }});
  }

  function onLeftClick(w, btn){
    if(paused) return;
    if(requireAnchor && !anchorTapped){
      anchorReminders++;
      if(currentSessionIdx>=0){ persist.sessions[currentSessionIdx].anchor_reminders = anchorReminders; savePersist(persist); }
      anchorBtn.classList.add('wiggle'); setTimeout(()=>anchorBtn.classList.remove('wiggle'),220); beep(360,120); return;
    }
    if(solvedLefts.has(w)) return;
    selectedLeft = w;
    ;[...leftList.children].forEach(el=> el.classList.remove('ring-2','ring-amber-500'));
    btn.classList.add('ring-2','ring-amber-500');
    const nowBase = Date.now() - sessionStart - totalPaused;
    currentTrial = { left: w, leftAtMs: nowBase, errors: 0, anchorAtMs };
  }

  function onRightClick(w, btn){
    if(paused) return;
    if(!selectedLeft){
      if(requireLeftStart){ rightFirstAttempts++; statRFA.textContent = String(rightFirstAttempts); if(currentSessionIdx>=0){ persist.sessions[currentSessionIdx].right_first_attempts = rightFirstAttempts; savePersist(persist);} btn.classList.add('wiggle'); setTimeout(()=>btn.classList.remove('wiggle'),220); beep(360,120); return; }
      else return;
    }
    const correct = pairMap[selectedLeft];
    const nowBase = Date.now() - sessionStart - totalPaused;
    if(w === correct){
      solvedLefts.add(selectedLeft); solvedRights.add(w);
      highlightPair(selectedLeft, w);
      ;[...leftList.children].forEach(el=> el.classList.remove('ring-2','ring-amber-500'));
      logs.push({
        trial: logs.length+1,
        left: selectedLeft,
        rightChosen: w,
        correct: 1,
        errorsBeforeCorrect: currentTrial?.errors||0,
        anchorAtMs: currentTrial?.anchorAtMs||0,
        leftAtMs: currentTrial?.leftAtMs||0,
        rightAtMs: nowBase,
        anchorToLeftLatencyMs: Math.max(0, (currentTrial?.leftAtMs||0) - (currentTrial?.anchorAtMs||0)),
        leftToRightLatencyMs: Math.max(0, nowBase - (currentTrial?.leftAtMs||0)),
      });
      const last = logs[logs.length-1];
      if(currentSessionIdx>=0){
        const rec = persist.sessions[currentSessionIdx];
        rec.trials.push(last);
        rec.errors = errors;
        rec.right_first_attempts = rightFirstAttempts;
        rec.idle_pauses = idlePauses;
        rec.anchor_reminders = anchorReminders;
        rec.pairCount = pairCount; rec.setName = setName;
        const nowAbs = Date.now();
        rec.active_time_ms = nowAbs - sessionStart - totalPaused;
        rec.total_time_ms = nowAbs - sessionStart;
        savePersist(persist);
      }
      selectedLeft = null; currentTrial = null; anchorTapped = false; anchorAtMs = 0; // require a fresh anchor next match
      updateStats();
      checkComplete();
    } else {
      errors++; statErr.textContent = String(errors); if(currentSessionIdx>=0){ persist.sessions[currentSessionIdx].errors = errors; savePersist(persist); } btn.classList.add('wiggle'); setTimeout(()=>btn.classList.remove('wiggle'),220); beep(260,140);
    }
  }

  function checkComplete(){
    const total = leftWords.length;
    if(solvedLefts.size === total && total>0){
      completeBanner.classList.remove('hidden');
    }
  }

  // Anchor stripe
  anchorBtn.addEventListener('click', ()=>{
    if(paused) return;
    anchorTapped = true; anchorAtMs = Date.now() - sessionStart - totalPaused;
    anchorBtn.classList.add('ring-4','ring-red-200'); setTimeout(()=>anchorBtn.classList.remove('ring-4','ring-red-200'),200);
  });

  // Stats
  function updateStats(){
    const total = leftWords.length; const solved = solvedLefts.size;
    statSolved.textContent = `${solved}/${total}`;
    const attempts = solved + errors; // accuracy = correct / (correct + errors)
    statAcc.textContent = attempts ? `${Math.round((solved/attempts)*100)}%` : '0%';
    statErr.textContent = String(errors);
    statRFA.textContent = String(rightFirstAttempts);
  }

  // Dynamically match anchor height to the taller column
  function adjustAnchorHeight(){
    const leftCard = leftList.parentElement; // the white card
    const rightCard = rightList.parentElement;
    const h = Math.max(leftCard.offsetHeight, rightCard.offsetHeight);
    anchorBtn.style.height = h + 'px';
  }

  // CSV export (across all persisted sessions)
  function downloadCSV(){
    finalizePersistSession();
    persist = loadPersist();

    const trialsHeader = ['session_index','session_id','setName','pairCount','trial','left','rightChosen','correct','errorsBeforeCorrect','anchorAtMs','leftAtMs','rightAtMs','anchorToLeftLatencyMs','leftToRightLatencyMs'];
    const trialRows = [];
    (persist.sessions||[]).forEach((s,idx)=>{
      (s.trials||[]).forEach(t=>{
        trialRows.push([idx+1, s.id, s.setName||'', s.pairCount||'', t.trial||'', t.left||'', t.rightChosen||'', t.correct||0, t.errorsBeforeCorrect||0, t.anchorAtMs||0, t.leftAtMs||0, t.rightAtMs||0, t.anchorToLeftLatencyMs||0, t.leftToRightLatencyMs||0]);
      });
    });

    const sumHeader = ['session_index','session_id','setName','pairCount','errors','anchor_reminders','right_first_attempts','idle_pauses','active_time_ms','total_time_ms'];
    const sumRows = (persist.sessions||[]).map((s,idx)=>[
      idx+1, s.id, s.setName||'', s.pairCount||'', s.errors||0, s.anchor_reminders||0, s.right_first_attempts||0, s.idle_pauses||0, Math.round(s.active_time_ms||0), Math.round(s.total_time_ms||0)
    ]);

    const csv = [
      ['TRIALS'], trialsHeader, ...trialRows,
      [], ['SUMMARY_PER_SESSION'], sumHeader, ...sumRows
    ].map(r=> r.join(',')).join('\n');

    const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = `word_scavenge_sessions_${new Date().toISOString().replace(/[:.]/g,'-')}.csv`;
    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  }

  // Kick off
  initControls(); newSession(); updateTime(true);

  </script>
</body>
</html>
